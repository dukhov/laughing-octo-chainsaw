full_ui.m

function full_ui()
    % Add utils subfolder to path
    if ~isdeployed 
        [current_script_folder, ~, ~] = fileparts(mfilename('fullpath'));
        fprintf('DEBUG (full_ui): Текущая папка скрипта full_ui.m: %s\n', current_script_folder);
        utils_folder_path = fullfile(current_script_folder, 'utils');
        fprintf('DEBUG (full_ui): Ожидаемый путь к папке utils: %s\n', utils_folder_path);

        if exist(utils_folder_path, 'dir')
            fprintf('INFO (full_ui): Папка utils найдена по пути: %s\n', utils_folder_path);
            if ~contains(path, utils_folder_path) % Проверяем, не добавлен ли уже путь
                addpath(utils_folder_path);
                fprintf('INFO (full_ui): Путь %s успешно добавлен в MATLAB path.\n', utils_folder_path);
                % Проверим, виден ли файл ПОСЛЕ добавления пути
                if exist('build_digital_twin.m', 'file') == 2
                    fprintf('INFO (full_ui): Файл build_digital_twin.m теперь ОБНАРУЖЕН в пути MATLAB.\n');
                else
                    fprintf('КРИТИЧЕСКАЯ ОШИБКА (full_ui): Файл build_digital_twin.m НЕ ОБНАРУЖЕН в пути MATLAB даже после добавления папки utils! Проверьте имя файла и его точное расположение внутри папки %s.\n', utils_folder_path);
                end
            else
                fprintf('INFO (full_ui): Папка utils (%s) уже была в пути MATLAB.\n', utils_folder_path);
                if exist('build_digital_twin.m', 'file') == 2
                    fprintf('INFO (full_ui): Файл build_digital_twin.m обнаружен в пути MATLAB (уже был там).\n');
                else
                    fprintf('КРИТИЧЕСКАЯ ОШИБКА (full_ui): Папка utils была в пути, но файл build_digital_twin.m все равно НЕ ОБНАРУЖЕН! Проверьте имя файла и его расположение.\n');
                end
            end
        else
            fprintf('КРИТИЧЕСКАЯ ОШИБКА (full_ui): Папка utils НЕ НАЙДЕНА по пути: %s.\n', utils_folder_path);
            fprintf('КРИТИЧЕСКАЯ ОШИБКА (full_ui): Убедитесь, что папка с именем "utils" (содержащая build_digital_twin.m) находится в той же директории, что и full_ui.m (%s), или добавьте путь к ней вручную.\n', current_script_folder);
        end
    end

    % Основное окно работы
    hFig = figure('Name', 'Диагностика', 'NumberTitle', 'off', ...
        'MenuBar', 'none', 'ToolBar', 'none', 'Units', 'normalized', ...
        'Position', [0,0,1,1], 'Color', [0.94 0.94 0.94], ...
        'CloseRequestFcn', @main_close_request_fcn);

    % Панель для выбора источника изображения
    hSourcePanel = uipanel('Parent', hFig, 'Title', 'Источник изображения', ...
                           'FontSize', 10, 'Units', 'normalized', ...
                           'Position', [0.05 0.82 0.45 0.13], 'BackgroundColor', [0.94 0.94 0.94]);

    hUseCamButton = uicontrol('Parent', hSourcePanel, 'Style', 'pushbutton', ...
                              'String', 'Использовать камеру', ...
                              'Units', 'normalized', 'Position', [0.05 0.15 0.43 0.7], ...
                              'FontSize', 10, 'Callback', @acquire_frame_from_camera_dialog_callback);

    hUploadButton = uicontrol('Parent', hSourcePanel, 'Style', 'pushbutton', ...
                              'String', 'Загрузить изображение', ...
                              'Units', 'normalized', 'Position', [0.52 0.15 0.43 0.7], ...
                              'FontSize', 10, 'Callback', @upload_image_from_file);

    % Ось для отображения изображения
    axCam = axes('Parent', hFig, 'Units', 'normalized', ...
                 'Position', [0.05 0.28 0.45 0.52]); 
    set(axCam, 'XTick', [], 'YTick', [], 'Box', 'on', 'Color', [1 1 1]);
    title(axCam, 'Область изображения', 'FontSize', 10);

    % Ось для графиков (теперь будет использоваться для цифрового двойника)
    axPlot = axes('Parent', hFig, 'Units', 'normalized', ...
                  'Position', [0.60 0.40 0.35 0.50]); 
    title(axPlot, 'Дополнительные данные / Цифровой двойник', 'FontSize', 10);
    axis(axPlot,'off'); % Initially turn off axis for axPlot

    % Панель для кнопок управления
    hControlPanel = uipanel('Parent', hFig, 'Title', 'Управление процессом', ...
                            'FontSize', 10, 'Units', 'normalized', ...
                            'Position', [0.05 0.03 0.9 0.23], 'BackgroundColor', [0.94 0.94 0.94]);

    hDrawROIButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                               'String','Нарисовать ROI', ...
                               'Units','normalized','Position',[0.02 0.70 0.22 0.25], ... 
                               'FontSize', 9, 'Callback',@draw_roi_callback, 'Enable', 'off');
    hConfirmROIButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                                 'String','Подтвердить ROI', ...
                                 'Units','normalized','Position',[0.26 0.70 0.22 0.25], ... 
                                 'FontSize', 9, 'Callback',@confirm_roi_callback, 'Enable', 'off');
    hUseFullImageButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                                   'String','Исп. всё изображение', ...
                                   'Units','normalized','Position',[0.50 0.70 0.22 0.25], ... 
                                   'FontSize', 9, 'Callback',@use_full_image_callback, 'Enable', 'off');
    
    hRecognizeButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                                 'String','Распознать', ...
                                 'Units','normalized','Position',[0.02 0.40 0.22 0.25], ... 
                                 'FontSize', 10, 'Callback',@recognize_callback_wrapper, 'Enable', 'off');
    hIRScanButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                              'String','ИК-сканирование', ... 
                              'Units','normalized','Position',[0.26 0.40 0.22 0.25], ... 
                              'FontSize', 9, 'Callback',@launch_multi_point_ir_scan_wrapper, 'Enable', 'off');
    
    hDigitalTwinButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                                   'String','Создать цифр. двойник (3D)', ... % Обновлено название кнопки
                                   'Units','normalized','Position',[0.02 0.10 0.22 0.25], ... 
                                   'FontSize', 9, 'Callback',@build_digital_twin_wrapper, 'Enable', 'off');
    hReportButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                              'String','Сохранить отчет PDF', ...
                              'Units','normalized','Position',[0.26 0.10 0.22 0.25], ... 
                              'FontSize', 10, 'Callback',@generate_report_wrapper, 'Enable', 'off');

    hResetButton = uicontrol('Parent', hControlPanel, 'Style','pushbutton',...
                             'String','Новое обследование', ...
                             'Units','normalized','Position',[0.76 0.10 0.22 0.85], ... 
                             'FontSize', 10, 'Callback',@reset_ui_callback, 'Enable', 'on');

    handles = struct('hFig', hFig, 'axCam', axCam, 'axPlot', axPlot, ...
                     'hUseCamButton', hUseCamButton, 'hUploadButton', hUploadButton, ...
                     'hRecognizeButton', hRecognizeButton, ...
                     'hIRScanButton', hIRScanButton, 'hDigitalTwinButton', hDigitalTwinButton, ...
                     'hReportButton', hReportButton, 'hResetButton', hResetButton, ...
                     'hDrawROIButton', hDrawROIButton, 'hConfirmROIButton', hConfirmROIButton, ...
                     'hUseFullImageButton', hUseFullImageButton, ...
                     'active_webcam_object', [], 'isImageLoaded', false, 'hImageOnAxCam', [], ...
                     'originalUploadedFrame', [], 'currentROI', [], 'captured_image_data', [], ...
                     'hSourcePanel', hSourcePanel, 'hControlPanel', hControlPanel);
    guidata(hFig, handles);
end 

function main_close_request_fcn(hObject, ~)
    fprintf('Closing application...\n');
    try 
        camera.capture_frame('clear'); 
    catch ME_clear_cam
        fprintf(2, 'Warning: Could not clear camera on close: %s\n', ME_clear_cam.message);
    end
    % Добавим digitalTwinGenerated к списку очищаемых переменных
    evalin('base', 'clear capturedFrame recognitionLabel recognitionScores irData irScanResults digitalTwin digitalTwinGenerated camera_object_managed_by_capture_frame');
    try 
        if ishandle(hObject)
            delete(hObject); 
        end
    catch ME_delete
        fprintf(2, 'Error deleting main figure: %s\n', ME_delete.message); 
    end
    disp('Приложение "Диагностика" закрыто.');
end

function reset_ui_callback(hObject, ~)
    handles = guidata(hObject);
    fprintf('Resetting UI...\n');
    try 
        camera.capture_frame('clear'); 
    catch 
    end 
    handles.active_webcam_object = [];

    cla(handles.axCam); title(handles.axCam, 'Область изображения');
    set(handles.axCam, 'XTick', [], 'YTick', []);
    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam), delete(handles.hImageOnAxCam); handles.hImageOnAxCam = []; end
    if ~isempty(handles.currentROI) && isvalid(handles.currentROI), delete(handles.currentROI); handles.currentROI = []; end
    handles.originalUploadedFrame = [];
    handles.captured_image_data = [];
    
    cla(handles.axPlot); title(handles.axPlot, 'Дополнительные данные / Цифровой двойник'); axis(handles.axPlot,'off'); % Turn off axis on reset
    view(handles.axPlot, 2); % Убедимся, что оси в 2D режиме после сброса
    % Добавим digitalTwinGenerated к списку очищаемых переменных
    evalin('base', 'clear capturedFrame recognitionLabel recognitionScores irData irScanResults digitalTwin digitalTwinGenerated');

    set(handles.hUseCamButton, 'Enable', 'on');
    set(handles.hUploadButton, 'Enable', 'on');
    set(handles.hDrawROIButton, 'Enable', 'off');
    set(handles.hConfirmROIButton, 'Enable', 'off');
    set(handles.hUseFullImageButton, 'Enable', 'off');
    set(handles.hRecognizeButton, 'Enable', 'off');
    set(handles.hIRScanButton, 'Enable', 'off');
    set(handles.hDigitalTwinButton, 'Enable', 'off');
    set(handles.hReportButton, 'Enable', 'off');
    
    handles.isImageLoaded = false;
    guidata(handles.hFig, handles);
end

function acquire_frame_from_camera_dialog_callback(hObject, ~)
    handles = guidata(hObject);
    reset_roi_state(handles); 
    
    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam), delete(handles.hImageOnAxCam); handles.hImageOnAxCam = []; end
    cla(handles.axCam); title(handles.axCam, 'Ожидание кадра с камеры...', 'FontSize', 10); drawnow;
    
    try 
        camera.capture_frame('clear'); 
    catch 
    end
    handles.active_webcam_object = [];

    set(handles.hFig, 'Pointer', 'watch'); drawnow;
    captured_frame_from_dialog = simple_camera_capture_ui(); 
    set(handles.hFig, 'Pointer', 'arrow');

    if ~isempty(captured_frame_from_dialog)
        disp('UI: Frame received from camera dialog.');
        process_acquired_image(handles.hFig, captured_frame_from_dialog, 'Кадр с камеры');
    else
        disp('UI: Camera dialog cancelled or no frame captured.');
        title(handles.axCam, 'Захват с камеры отменен.', 'FontSize', 10);
        set(handles.hUseCamButton, 'Enable', 'on'); 
        set(handles.hUploadButton, 'Enable', 'on'); 
    end
end

function process_acquired_image(hFig, frame_data, source_title_prefix)
    handles = guidata(hFig);

    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam), delete(handles.hImageOnAxCam); handles.hImageOnAxCam = []; end
    cla(handles.axCam); 
    handles.hImageOnAxCam = imshow(frame_data, 'Parent', handles.axCam); 
    axis(handles.axCam, 'image');
    title(handles.axCam, source_title_prefix, 'Interpreter', 'none', 'FontSize', 10);

    handles.originalUploadedFrame = frame_data; 
    handles.captured_image_data = []; 
    assignin('base', 'capturedFrame', []);

    set(handles.hDrawROIButton, 'Enable', 'on');
    set(handles.hUseFullImageButton, 'Enable', 'on');
    set(handles.hConfirmROIButton, 'Enable', 'off'); 
    set(handles.hRecognizeButton, 'Enable', 'off'); % Будет активировано после выбора ROI/Full
    set(handles.hIRScanButton, 'Enable', 'off');   % Будет активировано после выбора ROI/Full
    set(handles.hDigitalTwinButton, 'Enable', 'off'); % Деактивируем при новой картинке

    set(handles.hUseCamButton, 'Enable', 'on'); 
    set(handles.hUploadButton, 'Enable', 'on'); 
        
    handles.isImageLoaded = false; % Станет true после confirm_roi или use_full_image
    guidata(hFig, handles);
end

function upload_image_from_file(hObject, ~)
    handles = guidata(hObject);
    reset_roi_state(handles);

    try 
        camera.capture_frame('clear'); 
    catch 
    end
    handles.active_webcam_object = [];

    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam), delete(handles.hImageOnAxCam); handles.hImageOnAxCam = []; end
    cla(handles.axCam);

    [fileName, filePath] = uigetfile({'*.jpg;*.jpeg;*.png;*.bmp;*.tif;*.tiff', 'Image Files'}, 'Выберите изображение');
    if isequal(fileName,0) || isequal(filePath,0)
        title(handles.axCam, 'Загрузка отменена', 'FontSize', 10); return;
    end
    
    try 
        fullPath = fullfile(filePath, fileName); 
        frame = imread(fullPath);
    catch ME
        errordlg(sprintf('Не удалось загрузить изображение: %s', ME.message), 'Ошибка загрузки'); 
        return; 
    end
    
    process_acquired_image(handles.hFig, frame, ['Загружено: ' fileName]);
end

function draw_roi_callback(hObject, ~)
    handles = guidata(hObject);
    if isempty(handles.originalUploadedFrame)
        errordlg('Сначала получите изображение с камеры или загрузите из файла.', 'Ошибка'); 
        return; 
    end
    if ~isempty(handles.currentROI) && isvalid(handles.currentROI), delete(handles.currentROI); handles.currentROI = []; end
    
    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam)
        set(handles.hImageOnAxCam, 'CData', handles.originalUploadedFrame); 
    else 
        handles.hImageOnAxCam = imshow(handles.originalUploadedFrame, 'Parent', handles.axCam);
        axis(handles.axCam, 'image');
    end
    title(handles.axCam, 'Нарисуйте прямоугольник и подтвердите ROI', 'FontSize', 10);
    
    try
        handles.currentROI = drawrectangle(handles.axCam, 'LineWidth', 2, 'Color', 'r');
        if ~isempty(handles.currentROI) && isvalid(handles.currentROI)
             addlistener(handles.currentROI, 'MovingROI', @(src,evt) roi_moving_callback(src, evt, handles.hFig));
             addlistener(handles.currentROI, 'ROIMoved', @(src,evt) roi_moved_callback(src, evt, handles.hFig));
        end
        set(handles.hConfirmROIButton, 'Enable', 'on');
        set(handles.hDrawROIButton, 'String', 'Перерисовать ROI');
    catch ME
        errordlg(sprintf('Ошибка ROI: %s', ME.message), 'Ошибка ROI');
        if ~isempty(handles.currentROI) && isvalid(handles.currentROI), delete(handles.currentROI); end
        handles.currentROI = [];
        set(handles.hConfirmROIButton, 'Enable', 'off');
    end
    guidata(handles.hFig, handles);
end

function roi_moving_callback(~, evt, hFig) 
    handles = guidata(hFig); 
    if isempty(handles) || ~isfield(handles, 'originalUploadedFrame') || isempty(handles.originalUploadedFrame), return; end
    pos = evt.CurrentPosition; 
    imgSize = size(handles.originalUploadedFrame); 
    pos(1) = max(1, pos(1)); 
    pos(2) = max(1, pos(2)); 
    pos(3) = min(imgSize(2) - pos(1), pos(3)); 
    pos(4) = min(imgSize(1) - pos(2), pos(4)); 
    evt.Source.Position = pos; 
end

function roi_moved_callback(src, ~, hFig) 
    handles = guidata(hFig); 
    if isempty(handles) || ~isfield(handles, 'originalUploadedFrame') || isempty(handles.originalUploadedFrame), return; end
    pos = src.Position; 
    imgSize = size(handles.originalUploadedFrame);
    finalPos(1) = max(0.5, pos(1)); 
    finalPos(2) = max(0.5, pos(2)); 
    finalPos(3) = min(imgSize(2) - finalPos(1) + 0.5, pos(3)); 
    finalPos(4) = min(imgSize(1) - finalPos(2) + 0.5, pos(4)); 
    if finalPos(3) < 1, finalPos(3) = 1; end
    if finalPos(4) < 1, finalPos(4) = 1; end
    src.Position = finalPos; 
end

function confirm_roi_callback(hObject, ~)
    handles = guidata(hObject);
    if isempty(handles.currentROI) || ~isvalid(handles.currentROI) || isempty(handles.originalUploadedFrame)
        errordlg('ROI не выбран или изображение отсутствует.', 'Ошибка'); return;
    end
    roiPosition = round(handles.currentROI.Position); 
    if roiPosition(3) < 1 || roiPosition(4) < 1, errordlg('Выбранная область слишком мала.', 'Ошибка ROI'); return; end

    try 
        croppedImage = imcrop(handles.originalUploadedFrame, roiPosition);
    catch ME
        errordlg(sprintf('Ошибка обрезки: %s', ME.message), 'Ошибка обрезки'); return; 
    end
    if isempty(croppedImage), errordlg('Результат обрезки пуст.', 'Ошибка обрезки'); return; end

    handles.captured_image_data = croppedImage; 
    assignin('base', 'capturedFrame', croppedImage); % Для внешних модулей
    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam)
        set(handles.hImageOnAxCam, 'CData', croppedImage); 
    else
        handles.hImageOnAxCam = imshow(croppedImage, 'Parent', handles.axCam); 
        axis(handles.axCam, 'image');
    end
    title(handles.axCam, 'Выбранная область (ROI)', 'FontSize', 10);
    delete(handles.currentROI); handles.currentROI = [];

    set(handles.hRecognizeButton, 'Enable', 'on');
    set(handles.hIRScanButton, 'Enable', 'on'); 
    set(handles.hDrawROIButton, 'Enable', 'on'); % Можно перерисовать
    set(handles.hConfirmROIButton, 'Enable', 'off');
    set(handles.hUseFullImageButton, 'Enable', 'on'); % Можно вернуться к полному
    set(handles.hDrawROIButton, 'String', 'Нарисовать ROI'); 
    handles.isImageLoaded = true; 
    guidata(handles.hFig, handles);
end

function use_full_image_callback(hObject, ~)
    handles = guidata(hObject);
    if isempty(handles.originalUploadedFrame), errordlg('Сначала получите изображение.', 'Ошибка'); return; end
    
    handles.captured_image_data = handles.originalUploadedFrame; 
    assignin('base', 'capturedFrame', handles.originalUploadedFrame); % Для внешних модулей
    if ~isempty(handles.hImageOnAxCam) && isvalid(handles.hImageOnAxCam)
        set(handles.hImageOnAxCam, 'CData', handles.originalUploadedFrame); 
    else
        handles.hImageOnAxCam = imshow(handles.originalUploadedFrame, 'Parent', handles.axCam); 
        axis(handles.axCam, 'image');
    end
    title(handles.axCam, 'Полное изображение', 'FontSize', 10);
    if ~isempty(handles.currentROI) && isvalid(handles.currentROI), delete(handles.currentROI); handles.currentROI = []; end

    set(handles.hRecognizeButton, 'Enable', 'on');
    set(handles.hIRScanButton, 'Enable', 'on');
    set(handles.hDrawROIButton, 'Enable', 'on'); % Можно нарисовать ROI поверх
    set(handles.hConfirmROIButton, 'Enable', 'off');
    set(handles.hUseFullImageButton, 'Enable', 'off'); % Уже используем полное
    set(handles.hDrawROIButton, 'String', 'Нарисовать ROI');
    handles.isImageLoaded = true; 
    guidata(handles.hFig, handles);
end

function reset_roi_state(handles)
    if ~isempty(handles.currentROI) && isvalid(handles.currentROI)
        delete(handles.currentROI);
        handles.currentROI = [];
    end
    set(handles.hDrawROIButton, 'Enable', 'off', 'String', 'Нарисовать ROI');
    set(handles.hConfirmROIButton, 'Enable', 'off');
    set(handles.hUseFullImageButton, 'Enable', 'off');
end

function recognize_callback_wrapper(hObject, ~)
    handles = guidata(hObject);
    if ~handles.isImageLoaded || isempty(handles.captured_image_data)
        errordlg('Сначала необходимо получить изображение и выбрать область (или использовать полностью).', 'Ошибка');
        return;
    end
    
    image_to_recognize = handles.captured_image_data;
    set(handles.hFig, 'Pointer', 'watch');
    drawnow;

    try
        disp('Запуск распознавания (full_ui.m -> recognize_callback_wrapper)...');
        
        % Предполагается, что run_model.m находится в пути MATLAB
        [top_label_from_model, scores_from_model, model_class_names] = run_model(image_to_recognize);
        
        if strcmp(top_label_from_model, 'Ошибка')
            cla(handles.axPlot); title(handles.axPlot, 'Ошибка модели распознавания'); axis(handles.axPlot,'on'); view(handles.axPlot,2);
            set(handles.hFig, 'Pointer', 'arrow');
            return;
        end

        if isempty(model_class_names) || (~iscellstr(model_class_names) && ~isstring(model_class_names))  %#ok<ISCLSTR>
            errordlg('run_model.m не вернул корректный список имен классов (должен быть cellstr или string array).', 'Ошибка интеграции модели');
            cla(handles.axPlot); title(handles.axPlot, 'Ошибка имен классов модели'); axis(handles.axPlot,'on'); view(handles.axPlot,2);
            set(handles.hFig, 'Pointer', 'arrow');
            return;
        end
        model_class_names = cellstr(model_class_names); % Конвертируем в cellstr для единообразия

        if length(scores_from_model) ~= length(model_class_names)
            error_msg = sprintf(['Несоответствие данных от модели: Количество баллов (%d) не совпадает с количеством классов (%d) из run_model.m. ', ...
                                 'Проверьте логику в run_model.m.'], length(scores_from_model), length(model_class_names));
            errordlg(error_msg, 'Ошибка данных модели');
            cla(handles.axPlot); title(handles.axPlot, 'Ошибка данных модели'); axis(handles.axPlot,'on'); view(handles.axPlot,2);
            set(handles.hFig, 'Pointer', 'arrow');
            return;
        end
        
        recognition_results = table(model_class_names(:), scores_from_model(:), ...
                                    'VariableNames', {'Disease', 'Probability'});
        
        recognition_results = sortrows(recognition_results, 'Probability', 'descend');
        
        if isempty(recognition_results) || height(recognition_results) == 0
            errordlg('Результаты распознавания пусты после обработки.', 'Ошибка распознавания');
            cla(handles.axPlot); title(handles.axPlot, 'Нет результатов распознавания'); axis(handles.axPlot,'on'); view(handles.axPlot,2);
            set(handles.hFig, 'Pointer', 'arrow');
            return;
        end

        final_top_label = recognition_results.Disease{1};
        final_top_score = recognition_results.Probability(1); 

        assignin('base', 'recognitionLabel', final_top_label);
        assignin('base', 'recognitionScores', recognition_results); 

        current_title_obj = get(handles.axCam, 'Title');
        current_title_str = get(current_title_obj, 'String');
        title_text_suffix = sprintf('. Распознано: %s (Уверенность: %.2f%%)', final_top_label, final_top_score*100);
        
        base_title_str = '';
        if ischar(current_title_str)
            if contains(current_title_str, "Полное изображение")
                base_title_str = 'Полное изображение';
            elseif contains(current_title_str, "Выбранная область (ROI)")
                base_title_str = 'Выбранная область (ROI)';
            elseif contains(current_title_str, "Кадр с камеры")
                base_title_str = 'Кадр с камеры';
            else 
                base_title_str = current_title_str; 
                base_title_str = regexprep(base_title_str, '\. Распознано:.*', ''); 
            end
        end
        if isempty(base_title_str), base_title_str = 'Изображение'; end
        title(handles.axCam, [base_title_str, title_text_suffix]);

        disp(['Наиболее вероятный диагноз по модели: ' final_top_label]);

        % --- Логика для отображения данных в axPlot (график диагнозов) ---
        cla(handles.axPlot, 'reset'); % Сбрасываем оси перед новым графиком
        axis(handles.axPlot,'on'); 
        view(handles.axPlot,2); % Убедимся что оси в 2D для этого графика

        high_confidence_threshold = 0.99; 
        second_score_significance_threshold = 0.001; 

        if final_top_score >= high_confidence_threshold
            status_message_main_diagnosis = sprintf('Основной диагноз: %s (Уверенность: %.2f%%)', ...
                                     final_top_label, final_top_score*100);
            
            if height(recognition_results) >= 2 && recognition_results.Probability(2) >= second_score_significance_threshold
                second_label = recognition_results.Disease{2};
                second_score = recognition_results.Probability(2);
                labels_for_plot = {final_top_label; second_label};
                scores_for_plot = [final_top_score; second_score] * 100;
                bar(handles.axPlot, scores_for_plot);
                set(handles.axPlot, 'XTickLabel', labels_for_plot);
                xtickangle(handles.axPlot, 25);
                ylabel(handles.axPlot, 'Уверенность (%)');
                title(handles.axPlot, 'Топ-2 диагноза по уверенности', 'FontSize', 10);
                ylim(handles.axPlot, [0 105]);
            else
                text(0.5, 0.5, {status_message_main_diagnosis, 'Нет других значимых альтернатив.'}, ...
                     'Parent', handles.axPlot, 'HorizontalAlignment', 'center', 'FontSize', 9);
                axis(handles.axPlot, 'off'); 
            end
        else
            num_to_plot = min(5, height(recognition_results));
            if num_to_plot > 0
                top_diseases_for_plot = recognition_results.Disease(1:num_to_plot);
                top_probabilities_for_plot = recognition_results.Probability(1:num_to_plot);
                bar(handles.axPlot, top_probabilities_for_plot * 100);
                set(handles.axPlot, 'XTick', 1:num_to_plot);
                set(handles.axPlot, 'XTickLabel', top_diseases_for_plot);
                xtickangle(handles.axPlot, 45);
                ylabel(handles.axPlot, 'Вероятность (%)');
                xlabel(handles.axPlot, 'Диагноз');
                title(handles.axPlot, 'Топ вероятностей диагнозов (модель)', 'FontSize', 10);
                ylim(handles.axPlot, [0 max([top_probabilities_for_plot(:)'*100, 10])+5]);
            else
                title(handles.axPlot, 'Нет данных для отображения вероятностей', 'FontSize', 10);
                axis(handles.axPlot, 'off');
            end
        end
        grid(handles.axPlot, 'on');
        
        % Активация кнопок после успешного распознавания
        if evalin('base', "exist('irScanResults', 'var') && ~isempty(evalin('base','irScanResults'))")
             set(handles.hDigitalTwinButton, 'Enable', 'on');
        end
        % Кнопка отчета может быть активирована, если есть хотя бы распознавание
        set(handles.hReportButton, 'Enable', 'on');
        
    catch ME_rec
        cla(handles.axPlot, 'reset'); 
        title(handles.axPlot, 'Ошибка при распознавании'); axis(handles.axPlot,'on'); view(handles.axPlot,2);
        errordlg(['Ошибка в recognize_callback_wrapper: ' ME_rec.message], 'Ошибка распознавания');
        fprintf(2, 'Ошибка в recognize_callback_wrapper: %s\nИсточник: %s (строка %d)\n', ME_rec.message, ME_rec.stack(1).name, ME_rec.stack(1).line);
        for k_err=2:length(ME_rec.stack) 
            fprintf(2, '    в %s (строка %d)\n', ME_rec.stack(k_err).name, ME_rec.stack(k_err).line);
        end
    end
    
    set(handles.hFig, 'Pointer', 'arrow');
    drawnow; 
    guidata(hObject, handles);
end

function launch_multi_point_ir_scan_wrapper(hObject, ~) 
    handles = guidata(hObject);
    if ~handles.isImageLoaded || isempty(handles.captured_image_data)
        errordlg('Сначала необходимо получить изображение и выбрать область (или использовать полностью).', 'Ошибка');
        return;
    end
    current_frame_for_scan = handles.captured_image_data;
    
    set(handles.hFig, 'Pointer', 'watch'); disp('Запуск multi_point_ir_scan_ui...');
    % Предполагается, что multi_point_ir_scan_ui.m находится в пути MATLAB
    ir_scan_results_table = multi_point_ir_scan_ui(current_frame_for_scan, handles.hFig); 
    set(handles.hFig, 'Pointer', 'arrow');

    if ~isempty(ir_scan_results_table) && istable(ir_scan_results_table) && height(ir_scan_results_table) > 0
        assignin('base', 'irScanResults', ir_scan_results_table); 
        disp('Результаты ИК-сканирования получены:'); disp(ir_scan_results_table);
        
        % Активируем кнопку цифрового двойника, если есть результаты ИК
        set(handles.hDigitalTwinButton, 'Enable', 'on');
        
        % Активируем кнопку отчета, если есть и распознавание, и ИК
        if evalin('base', "exist('recognitionLabel', 'var') && ~isempty(evalin('base','recognitionLabel'))")
            set(handles.hReportButton, 'Enable', 'on');
        end
    else
        disp('Многоточечное ИК-сканирование отменено или нет валидных результатов.');
        assignin('base', 'irScanResults', []); % Сохраняем пустой результат
        set(handles.hDigitalTwinButton, 'Enable', 'off'); % Деактивируем, если нет ИК данных
    end
    guidata(hObject, handles);
end

% --- МОДИФИЦИРОВАННАЯ ФУНКЦИЯ ---
function build_digital_twin_wrapper(hObject, ~) 
    handles = guidata(hObject);

    % --- Input Data Check ---
    % 1. Image loaded and processed (ROI or full)
    if ~handles.isImageLoaded || isempty(handles.captured_image_data)
        errordlg('Для создания цифрового двойника необходимо сначала загрузить и обработать изображение (ROI или полное).', 'Ошибка данных');
        return;
    end
    
    % 2. IR Scan results available in base workspace
    ir_results_exist = evalin('base', "exist('irScanResults', 'var')");
    if ir_results_exist
        ir_scan_table = evalin('base', 'irScanResults');
        if isempty(ir_scan_table) || ~istable(ir_scan_table) || ~all(ismember({'X', 'Y', 'Voltage'}, ir_scan_table.Properties.VariableNames)) || height(ir_scan_table)==0
            errordlg('Данные ИК-сканирования (irScanResults) отсутствуют, пусты или имеют неверный формат (ожидается непустая таблица с X, Y, Voltage).', 'Ошибка данных ИК');
            return;
        end
    else
        errordlg('Данные ИК-сканирования (irScanResults) не найдены в рабочей области.', 'Ошибка данных ИК');
        return;
    end

    disp('UI: Запуск построения 3D цифрового двойника...');
    set(handles.hFig, 'Pointer', 'watch');
    drawnow;

    try
        % --- Prepare data for the digital twin function ---
        roi_image_for_boundaries = handles.captured_image_data; 
        target_axes_for_3d_plot = handles.axPlot; 

        % --- ИСПРАВЛЕННЫЙ БЛОК ВЫЗОВА ---
        if exist('build_digital_twin.m', 'file') == 2
            disp('DEBUG (wrapper): Попытка прямого вызова build_digital_twin...');
            % Вызываем напрямую, т.к. addpath должен был добавить папку utils
            build_digital_twin(ir_scan_table, roi_image_for_boundaries, target_axes_for_3d_plot);
            disp('DEBUG (wrapper): Прямой вызов build_digital_twin выполнен.');
        else
            % Эта ошибка будет более информативной, если addpath не сработал
            error_msg_bdt_nf = ['Функция build_digital_twin.m не найдена в пути MATLAB. ' ...
                                '1. Убедитесь, что файл build_digital_twin.m (для 3D модели) существует и его имя написано правильно. ' ...
                                '2. Убедитесь, что он находится в папке с именем "utils". ' ...
                                '3. Убедитесь, что папка "utils" находится в той же директории, что и full_ui.m. ' ...
                                '4. Проверьте сообщения DEBUG/INFO/ERROR в командном окне при запуске full_ui, касающиеся добавления пути к utils.'];
            disp(error_msg_bdt_nf); % Выводим также в консоль
            % Используем более специфичный ID ошибки для облегчения отладки
            error('BuildDigitalTwin:NotFound', error_msg_bdt_nf); 
        end
        % --- КОНЕЦ ИСПРАВЛЕННОГО БЛОКА ВЫЗОВА ---
        
        disp('UI: 3D цифровой двойник успешно построен и отображен в axPlot.');
        
        assignin('base', 'digitalTwinGenerated', true); 
        
        if evalin('base', "exist('recognitionLabel', 'var') && ~isempty(evalin('base','recognitionLabel'))") && ...
           evalin('base', "exist('irScanResults', 'var') && ~isempty(evalin('base','irScanResults'))")
            set(handles.hReportButton, 'Enable', 'on');
        end

    catch ME_build_twin
        % ... остальной блок catch остается без изменений ...
        errMsg = sprintf('Ошибка при построении 3D цифрового двойника:\n%s (ID: %s)', ME_build_twin.message, ME_build_twin.identifier);
        for i_err = 1:length(ME_build_twin.stack)
            errMsg = sprintf('%s\n  В файле: %s, функция: %s, строка: %d', errMsg, ...
                             ME_build_twin.stack(i_err).file, ME_build_twin.stack(i_err).name, ME_build_twin.stack(i_err).line);
        end
        disp(errMsg); 
        errordlg(errMsg, 'Ошибка построения 3D модели');
        
        cla(handles.axPlot, 'reset');
        title(handles.axPlot, 'Ошибка построения 3D модели');
        text(handles.axPlot, 0.5, 0.5, 'Не удалось построить 3D модель.', 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
        view(handles.axPlot, 2); 
        axis(handles.axPlot, 'off');
        assignin('base', 'digitalTwinGenerated', false);
    end
    
    set(handles.hFig, 'Pointer', 'arrow');
    guidata(hObject, handles);
end
% --- КОНЕЦ МОДИФИЦИРОВАННОЙ ФУНКЦИИ ---

function generate_report_wrapper(hObject, ~) 
    handles = guidata(hObject);
    if isempty(handles.captured_image_data)
         errordlg('Для отчета отсутствует обработанный кадр в UI.', 'Ошибка данных для отчета'); return;
    end
    assignin('base', 'capturedFrame_size', size(handles.captured_image_data)); 

    % Обновляем проверку: digitalTwinGenerated вместо сложной структуры digitalTwin
    required_vars_exist = {
        "exist('capturedFrame_size', 'var')", ...
        "exist('recognitionLabel', 'var') && ~isempty(evalin('base','recognitionLabel'))", ...
        "exist('recognitionScores', 'var') && ~isempty(evalin('base','recognitionScores')) && height(evalin('base','recognitionScores')) > 0", ...
        "exist('irScanResults', 'var') && ~isempty(evalin('base','irScanResults')) && height(evalin('base','irScanResults')) > 0", ...
        "exist('digitalTwinGenerated', 'var') && evalin('base','digitalTwinGenerated') == true"
    };
    
    missing_vars_desc = {'Размер кадра', 'Метка распознавания', 'Оценки распознавания', 'Результаты ИК-сканирования', 'Статус генерации ЦД'};
    
    all_data_ok = true;
    missing_data_messages = {};

    for i = 1:length(required_vars_exist)
        if ~evalin('base', required_vars_exist{i})
            all_data_ok = false;
            missing_data_messages{end+1} = missing_vars_desc{i}; %#ok<AGROW>
        end
    end

    if ~all_data_ok
        errordlg(sprintf('Для отчета отсутствуют или некорректны следующие данные: %s.', strjoin(unique(missing_data_messages), ', ')), 'Ошибка данных для отчета');
        return;
    end
    
    disp('Запуск generate_report...');
    
    [file, path] = uiputfile('Отчет_Диагностики.pdf', 'Сохранить отчет как PDF');
    if isequal(file,0) || isequal(path,0)
        disp('Сохранение отчета отменено.');
        return;
    end
    
    % Собираем данные для отчета
    report_data.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
    report_data.original_image = handles.originalUploadedFrame; % Исходное полное изображение
    report_data.processed_image = handles.captured_image_data; % ROI или полное, которое обрабатывалось
    report_data.recognitionLabel = evalin('base','recognitionLabel');
    report_data.recognitionScores = evalin('base','recognitionScores');
    report_data.irScanResults = evalin('base','irScanResults');
    % digitalTwinGenerated уже проверен, сам 3D график находится в handles.axPlot
    
    % Создание PDF (заглушка, требует Report Generator или кастомной логики)
    try
        set(handles.hFig, 'Pointer', 'watch'); drawnow;
        
        % --- Кастомная логика генерации PDF ---
        % Это сложная часть, которая здесь не реализована полностью.
        % Примерный план:
        % 1. Создать временную фигуру (невидимую).
        % 2. Скопировать handles.axCam и handles.axPlot на эту фигуру.
        % 3. Добавить текстовую информацию (диагноз, ИК данные и т.д.).
        % 4. Использовать print() для сохранения фигуры в PDF.
        % Например: print(tempFig, fullfile(path, file), '-dpdf', '-bestfit');
        % delete(tempFig);
        
        % Вместо полного PDF, пока сохраним .mat с данными и выведем сообщение
        save(fullfile(path, [file(1:end-3) 'mat']), '-struct', 'report_data'); 
        msgbox(sprintf('PDF отчет (заглушка). Данные для отчета сохранены в:\n%s.mat', fullfile(path, file(1:end-4))), 'Генерация отчета');
        disp('Отчет сгенерирован (заглушка - данные сохранены в .mat).');
        
        set(handles.hFig, 'Pointer', 'arrow');
    catch ME_report
        set(handles.hFig, 'Pointer', 'arrow');
        errordlg(sprintf('Ошибка при генерации/сохранении отчета: %s', ME_report.message), 'Ошибка отчета');
    end
    guidata(hObject,handles);
end

main_app.m

function main_app()
    % Главное окно
    f = figure('Name', 'Система диагностики кожных покровов', ...
        'NumberTitle', 'off', 'MenuBar', 'none', 'ToolBar', 'none', ...
        'Units', 'normalized', 'Position', [0, 0, 1, 1], ...
        'Color', [1 1 1]);

    % Заголовок
    uicontrol('Style', 'text', 'String', 'Оптическая система диагностики кожного покрова', ...
        'FontSize', 24, 'FontWeight', 'bold', ...
        'Units', 'normalized', 'Position', [0.2 0.6 0.6 0.1], ...
        'BackgroundColor', [1 1 1]);

    % Описание
    uicontrol('Style', 'text', 'String', 'Использование ИИ и ИК-сканирования для распознавания поражений кожи', ...
        'FontSize', 16, ...
        'Units', 'normalized', 'Position', [0.25 0.5 0.5 0.05], ...
        'BackgroundColor', [1 1 1]);

    % Кнопка начала
    uicontrol('Style', 'pushbutton', 'String', 'Начать обследование', ...
        'FontSize', 18, 'Callback', @start_examination, ...
        'Units', 'normalized', 'Position', [0.4 0.35 0.2 0.1]);
end

function start_examination(~, ~)
    % Add model folder to path if not already on it
    modelFolder = fullfile(fileparts(mfilename('fullpath')), 'model');
    if exist(modelFolder, 'dir') && ~contains(path, modelFolder)
        addpath(modelFolder);
        disp(['Added to path: ', modelFolder]);
    end
    
    % Add +camera parent folder to path if not already on it
    cameraPackageParentFolder = fileparts(mfilename('fullpath')); % Assumes +camera is in the same dir as main_app.m
     if exist(fullfile(cameraPackageParentFolder, '+camera'), 'dir') && ~contains(path, cameraPackageParentFolder)
        addpath(cameraPackageParentFolder);
        disp(['Added to path: ', cameraPackageParentFolder, ' (for +camera package)']);
    end

    close(gcf);
    full_ui();
end

multi_point_ir_scan_ui.m

function data_table_out = multi_point_ir_scan_ui_v15(current_image_for_display, ~)
    % --- Инициализация ---
    data_table_out = cell(0, 4); 
    tcp_client = [];
    scan_data_internal = zeros(0, 4); % [PointIndex, X, Y, Voltage]
    
    selectedPoints_app  = zeros(0,2); 
    markers_app         = gobjects(0);    
    labels_app          = gobjects(0);    
    confirmed_app       = false;          
    editingIndex_app    = 0;              
    hImg_app            = [];             

    hPlotScan_internal = [];   
    isScanning_process_active = false; 
    selected_table_row_for_rescan = []; 
    
    axImage = []; 
    hStatusTextOverall = []; 
    hStartSequenceScanButton = []; 
    hStopSequenceScanButton = []; 
    hInstructionText = []; 
    hFixPointsButton = []; 
    hRescanButton = [];
    hFinishButton = [];
    hConnectButton = [];
    hIPEdit = [];
    hConnectionStatus = [];
    hScanDataTable = [];
    axScanPlot = [];
    
    current_point_being_scanned_index_val = 0; 
    
    STATE_INITIAL = 1;
    STATE_MARKING_POINTS = 2; 
    STATE_POINTS_FIXED = 3;   
    STATE_SEQUENCE_SCANNING = 4; 
    
    current_ui_state = STATE_INITIAL;
    
    POINT_LABEL_OFFSET_X = 8; 
    POINT_LABEL_OFFSET_Y = 8; 


    % --- Создание UI ---
    screenSize = get(0, 'ScreenSize');
    figWidth = 1200; 
    figHeight = 800; 
    figPos = [(screenSize(3)-figWidth)/2, (screenSize(4)-figHeight)/2, figWidth, figHeight];

    hFig = figure('Name', 'Многоточечное ИК-сканирование v15 (Разметка и Скан)', 'NumberTitle', 'off', ...
                  'MenuBar', 'none', 'ToolBar', 'none', 'Units', 'pixels', ...
                  'Position', figPos, 'CloseRequestFcn', @close_fig_callback, ...
                  'Visible', 'off'); 
    
    hLeftPanel = uipanel('Parent', hFig, 'Units', 'normalized', 'Position', [0.02 0.08 0.55 0.9]);
    hImagePanel = uipanel('Parent', hLeftPanel, 'Title', 'Разметка фотографии (клик для добавления точек)', 'FontSize', 10, ...
                          'Units', 'normalized', 'Position', [0.02 0.25 0.96 0.74]); 
    axImage = axes('Parent', hImagePanel, 'Units', 'normalized', 'Position', [0.05 0.05 0.9 0.9]);
    set(axImage, 'XTick', [], 'YTick', []);
    title(axImage, 'Подключитесь к датчику.');

    hMarkingPanel = uipanel('Parent', hLeftPanel, 'Title', 'Управление разметкой', 'FontSize', 10, ...
                               'Units', 'normalized', 'Position', [0.02 0.02 0.96 0.21]); 
    uicontrol('Parent', hMarkingPanel, 'Style', 'text', 'String', 'Кликайте на фото для добавления точек (после подключения).', ...
              'Units', 'normalized', 'Position', [0.05 0.55 0.9 0.35], 'HorizontalAlignment', 'center');
    hFixPointsButton = uicontrol('Parent', hMarkingPanel, 'Style', 'pushbutton', 'String', 'Закрепить точки и перейти к сканированию', ...
                                 'Units', 'normalized', 'Position', [0.05 0.1 0.9 0.35], 'Enable', 'off', ...
                                 'Callback', @fix_points_callback);
    
    hRightPanel = uipanel('Parent', hFig, 'Units', 'normalized', 'Position', [0.58 0.08 0.4 0.9]);
    hConnectionPanel = uipanel('Parent', hRightPanel, 'Title', 'Подключение к датчику', 'FontSize', 10, ...
                               'Units', 'normalized', 'Position', [0.05 0.85 0.9 0.14]); 
    uicontrol('Parent', hConnectionPanel, 'Style', 'text', 'String', 'IP датчика:', ...
              'Units', 'normalized', 'Position', [0.05 0.6 0.2 0.25], 'HorizontalAlignment', 'right');
    hIPEdit = uicontrol('Parent', hConnectionPanel, 'Style', 'edit', 'String', '192.168.0.100', ... 
                        'Units', 'normalized', 'Position', [0.27 0.6 0.4 0.3]);
    hConnectButton = uicontrol('Parent', hConnectionPanel, 'Style', 'pushbutton', 'String', 'Подключить', ...
                               'Units', 'normalized', 'Position', [0.7 0.6 0.25 0.3], ...
                               'Callback', @connect_button_callback);
    hConnectionStatus = uicontrol('Parent', hConnectionPanel, 'Style', 'text', 'String', 'Отключено', ...
                                  'Units', 'normalized', 'Position', [0.05 0.15 0.9 0.3], 'ForegroundColor', 'r', 'FontSize',9);

    hScanSequencePanel = uipanel('Parent', hRightPanel, 'Title', 'Сканирование размеченных точек', 'FontSize', 10, ...
                             'Units', 'normalized', 'Position', [0.05 0.65 0.9 0.18]); 
    hTablePanel = uipanel('Parent', hRightPanel, 'Title', 'Данные сканирования', 'FontSize', 10, ...
                          'Units', 'normalized', 'Position', [0.05 0.35 0.9 0.26]); 
    hRescanPanel = uipanel('Parent', hRightPanel, 'Title', 'Действия с точкой', 'FontSize', 10, ...
                           'Units', 'normalized', 'Position', [0.05 0.26 0.9 0.08]); 
    hPlotPanel = uipanel('Parent', hRightPanel, 'Title', 'График напряжения', 'FontSize', 10, ...
                         'Units', 'normalized', 'Position', [0.05 0.02 0.9 0.23]); 
    
    hInstructionText = uicontrol('Parent', hScanSequencePanel, 'Style', 'text', 'String', 'Инструкция: Закрепите точки для начала.', ...
              'Units', 'normalized', 'Position', [0.05 0.55 0.9 0.35], 'HorizontalAlignment', 'center', 'FontSize', 9);
    hStartSequenceScanButton = uicontrol('Parent', hScanSequencePanel, 'Style', 'pushbutton', 'String', 'Начать сканирование точек', ...
                                     'Units', 'normalized', 'Position', [0.05 0.1 0.43 0.35], 'Enable', 'off',...
                                     'Callback', @start_sequence_scan_callback);
    hStopSequenceScanButton = uicontrol('Parent', hScanSequencePanel, 'Style', 'pushbutton', 'String', 'Остановить', ...
                                    'Units', 'normalized', 'Position', [0.52 0.1 0.43 0.35], 'Enable', 'off',...
                                    'Callback', @stop_sequence_scan_callback);
    
    hScanDataTable = uitable('Parent', hTablePanel, 'Units', 'normalized', 'Position', [0.02 0.02 0.96 0.96], ...
                             'ColumnName', {'Точка', 'X', 'Y', 'Напряжение (V)'}, ...
                             'ColumnEditable', [false false false false], ...
                             'ColumnWidth', {50, 60, 60, 'auto'}, ... 
                             'Data', cell(0,4), ... 
                             'RowName', [], 'CellSelectionCallback', @table_cell_select_callback_app);
    
    hRescanButton = uicontrol('Parent', hRescanPanel, 'Style', 'pushbutton', 'String', 'Переснять выбранную точку', ...
                              'Units', 'normalized', 'Position', [0.1 0.15 0.8 0.7], 'Enable', 'off', ...
                              'Callback', @rescan_point_callback);
    
    axScanPlot = axes('Parent', hPlotPanel, 'Units', 'normalized', 'Position', [0.12 0.18 0.83 0.75]); 
    xlabel(axScanPlot, 'Номер точки'); ylabel(axScanPlot, 'Напряжение (V)'); grid(axScanPlot, 'on');
    
    hStatusTextOverall = uicontrol('Parent', hFig, 'Style', 'text', 'String', 'Ожидание подключения...', ...
                                   'Units', 'normalized', 'Position', [0.02 0.02 0.55 0.04], 'FontSize', 9, 'HorizontalAlignment','left');
    hFinishButton = uicontrol('Parent', hFig, 'Style', 'pushbutton', 'String', 'Завершить и закрыть', ...
                              'Units', 'normalized', 'Position', [0.78 0.02 0.2 0.04], 'FontSize', 9, ...
                              'Callback', @finish_button_callback, 'Enable', 'off');
    
    update_ui_for_state(STATE_INITIAL); 
    set(hFig, 'WindowState', 'maximized');
    set(hFig, 'Visible', 'on');  
    uiwait(hFig); 

    %% --- Коллбэки ---
    function update_ui_for_state(new_state)
        current_ui_state = new_state;
        disp(['DEBUG: Переход в состояние UI: ' num2str(current_ui_state)]);
        
        set(hIPEdit, 'Enable', 'on'); 
        set(hConnectButton, 'Enable', 'on', 'String', 'Подключить'); 
        set(hConnectButton, 'Callback', @connect_button_callback); 
        
        if ~isempty(hImg_app) && ishandle(hImg_app) && isvalid(hImg_app)
            set(hImg_app, 'ButtonDownFcn', ''); 
        end

        set(hFixPointsButton, 'Enable', 'off');
        set(hStartSequenceScanButton, 'Enable', 'off');
        set(hStopSequenceScanButton, 'Enable', 'off');
        set(hRescanButton, 'Enable', 'off'); 
        set(hFinishButton, 'Enable', 'off');
        set(hInstructionText, 'String', 'Подключитесь к датчику для начала работы.'); % Используем String

        switch current_ui_state
            case STATE_INITIAL
                title(axImage,'Подключитесь к датчику.');
            case STATE_MARKING_POINTS 
                set(hIPEdit, 'Enable', 'off');
                set(hConnectButton, 'String', 'Отключить');
                set(hConnectButton, 'Callback', @disconnect_button_callback);
                set(hFinishButton,'Enable','on');
                if ~isempty(hImg_app) && ishandle(hImg_app) && isvalid(hImg_app)
                    set(hImg_app, 'ButtonDownFcn', @onImageClick_app); 
                    title(axImage,'Кликните для добавления точек'); 
                    disp('DEBUG: ButtonDownFcn УСТАНОВЛЕН для hImg_app в STATE_MARKING_POINTS.');
                else
                    title(axImage,'Изображение не загружено. Кликните "Подключить", если изображение передано.');
                    disp('DEBUG: Изображение не загружено (hImg_app пуст или невалиден), ButtonDownFcn для hImg_app не установлен.');
                end
                set(hInstructionText, 'String', 'Кликайте на фото для добавления точек.'); % Используем String
                if ~isempty(selectedPoints_app) && size(selectedPoints_app,1) > 0 
                    set(hFixPointsButton, 'Enable', 'on'); 
                end
                if ~isempty(selected_table_row_for_rescan) && confirmed_app == false 
                     set(hRescanButton, 'Enable', 'on');
                end

            case STATE_POINTS_FIXED 
                set(hIPEdit, 'Enable', 'off');
                set(hConnectButton, 'String', 'Отключить');
                set(hConnectButton, 'Callback', @disconnect_button_callback);
                set(hFinishButton,'Enable','on');
                if ~isempty(hImg_app) && ishandle(hImg_app) && isvalid(hImg_app)
                    set(hImg_app, 'ButtonDownFcn', ''); 
                end 
                arrayfun(@(m) set(m, 'ButtonDownFcn', ''), markers_app(isgraphics(markers_app))); 
                disp('DEBUG: ButtonDownFcn ОЧИЩЕН для hImg_app и маркеров в STATE_POINTS_FIXED.');
                set(hFixPointsButton, 'Enable', 'off'); 
                
                if ~isempty(scan_data_internal) && size(scan_data_internal,1) > 0 && confirmed_app
                    set(hStartSequenceScanButton, 'Enable', 'on');
                else
                    set(hStartSequenceScanButton, 'Enable', 'off'); 
                end
                set(hInstructionText, 'String', 'Точки закреплены. Нажмите "Начать сканирование".'); % Используем String
                if ~isempty(selected_table_row_for_rescan) 
                     set(hRescanButton, 'Enable', 'on');
                end
            case STATE_SEQUENCE_SCANNING 
                set(hIPEdit, 'Enable', 'off');
                set(hConnectButton, 'Enable', 'off'); 
                if ~isempty(hImg_app) && ishandle(hImg_app) && isvalid(hImg_app)
                     set(hImg_app, 'ButtonDownFcn', ''); 
                end 
                arrayfun(@(m) set(m, 'ButtonDownFcn', ''), markers_app(isgraphics(markers_app)));
                set(hFixPointsButton, 'Enable', 'off');
                set(hStartSequenceScanButton, 'Enable', 'off');
                set(hStopSequenceScanButton, 'Enable', 'on');
                set(hRescanButton, 'Enable', 'off'); 
                set(hFinishButton,'Enable','off');
        end
        drawnow;
    end

    function connect_button_callback(~, ~)
        ip_address = get(hIPEdit, 'String'); 
        port = 8888;
        try
            set(hStatusTextOverall, 'String', ['Подключение к ' ip_address '...']); drawnow; % Используем String
            tcp_client = tcpclient(ip_address, port, 'Timeout', 10, 'ConnectTimeout', 5);
            if ~isempty(tcp_client) && strcmp(tcp_client.Status, 'open')
                set(hConnectionStatus, 'String', 'Подключено'); set(hConnectionStatus, 'ForegroundColor', 'g'); % Используем String
                set(hStatusTextOverall, 'String', 'Подключено. Кликайте на фото для разметки точек.'); % Используем String
                if tcp_client.NumBytesAvailable > 0, read(tcp_client, tcp_client.NumBytesAvailable); end
                
                reset_marking_state(); 
                update_table_and_plot(); 
                
                if isempty(hImg_app) || ~isvalid(hImg_app) 
                    if ~isempty(current_image_for_display) && isnumeric(current_image_for_display)
                        axes(axImage); 
                        hImg_app = imshow(current_image_for_display, 'Parent', axImage);
                        axis(axImage, 'image'); 
                        hold(axImage, 'on');    
                        disp('DEBUG: Изображение (current_image_for_display) отображено при подключении.');
                    else
                         title(axImage,'Изображение не загружено. Разметка невозможна.');
                         disp('DEBUG: Изображение не было передано или не загружено ранее.');
                    end
                else 
                    axes(axImage); 
                    cla(axImage); 
                    hImg_app = imshow(current_image_for_display, 'Parent', axImage); 
                    axis(axImage, 'image'); 
                    hold(axImage, 'on'); 
                    disp('DEBUG: Используется/перерисовано изображение.');
                end
                
                update_ui_for_state(STATE_MARKING_POINTS); 

            else
                error('Не удалось установить соединение.');
            end
        catch ME
            set(hConnectionStatus, 'String', 'Ошибка подключения');set(hConnectionStatus, 'ForegroundColor', 'r'); % Используем String
            set(hStatusTextOverall, 'String', ['Ошибка: ' ME.message]); % Используем String
            if ~isempty(tcp_client), clear tcp_client; tcp_client = []; end
            update_ui_for_state(STATE_INITIAL);
        end
    end
    
    function reset_marking_state()
        selectedPoints_app = zeros(0,2);
        delete(markers_app(isgraphics(markers_app))); markers_app = gobjects(0);
        delete(labels_app(isgraphics(labels_app)));  labels_app  = gobjects(0);
        confirmed_app = false; 
        editingIndex_app = 0;
        scan_data_internal = zeros(0,4); 
        current_point_being_scanned_index_val = 0;
        
        if ishandle(axImage) 
            cla(axImage);
            title(axImage,'Подключитесь к датчику.'); 
        end
        hImg_app = []; 
        
        update_points_on_image_app(); 
        disp('DEBUG: Состояние разметки и изображение сброшено.');
    end

    function disconnect_button_callback(~,~)
        close_tcp_connection();
        set(hConnectionStatus, 'String', 'Отключено'); set(hConnectionStatus, 'ForegroundColor', 'r'); % Используем String
        set(hStatusTextOverall, 'String', 'Отключено. Готово к новому подключению.'); % Используем String
        reset_marking_state(); 
        update_table_and_plot();
        update_ui_for_state(STATE_INITIAL);
    end
    
    function onImageClick_app(src,evt) 
        disp('--- DEBUG: onImageClick_app ВЫЗВАН ---');
        if isempty(hImg_app) || ~isvalid(hImg_app) || confirmed_app || current_ui_state ~= STATE_MARKING_POINTS
            disp('DEBUG: onImageClick_app: Выход (условия не выполнены).');
            return;
        end
        current_point_axes = get(axImage, 'CurrentPoint');
        pt = current_point_axes(1,1:2); 
        x = pt(1); y = pt(2);
        disp(['DEBUG: onImageClick_app: Клик на X=' num2str(x) ', Y=' num2str(y)]);
        xl = xlim(axImage); yl = ylim(axImage);
        if x<xl(1)||x>xl(2)||y<yl(1)||y>yl(2)
            disp('DEBUG: onImageClick_app: Клик за пределами изображения.'); return;
        end
        axes(axImage); 
        hold(axImage,'on'); 
        if editingIndex_app > 0 && editingIndex_app <= size(selectedPoints_app,1)
            disp(['DEBUG: onImageClick_app: Перемещение точки #' num2str(editingIndex_app)]);
            selectedPoints_app(editingIndex_app,:) = [x,y];
            set(markers_app(editingIndex_app),'XData',x,'YData',y);
            if ishandle(labels_app(editingIndex_app)) && isvalid(labels_app(editingIndex_app))
                 set(labels_app(editingIndex_app), 'Position', [x+POINT_LABEL_OFFSET_X, y+POINT_LABEL_OFFSET_Y, 0]); 
            end
            scan_data_internal(editingIndex_app, 2:3) = [x,y];
            editingIndex_app = 0; 
            title(axImage,'Кликните для добавления или выберите маркер для правки');
        else
            disp('DEBUG: onImageClick_app: Добавление новой точки.');
            selectedPoints_app(end+1,:) = [x,y];
            idx = size(selectedPoints_app,1); 
            h_marker = plot(axImage,x,y,'ro','MarkerFaceColor','r','MarkerSize',8, ...
                             'ButtonDownFcn',@(s,e)onMarkerClick_app(s,idx,e)); 
            markers_app(idx) = h_marker; 
            h_label = text(axImage, x+POINT_LABEL_OFFSET_X, y+POINT_LABEL_OFFSET_Y, num2str(idx), ...
                           'Color','blue','FontWeight','bold', 'PickableParts','none');
            labels_app(idx) = h_label;
            scan_data_internal(idx,:) = [idx, x, y, NaN];
            set(hFixPointsButton, 'Enable', 'on'); 
            title(axImage,sprintf('Добавлена точка #%d. Кликните для еще одной или выберите маркер.', idx));
        end
        hold(axImage,'off');
        update_table_and_plot(); 
        disp('--- DEBUG: onImageClick_app ЗАВЕРШЕН ---');
    end

    function onMarkerClick_app(src,idx,~) 
        disp(['--- DEBUG: onMarkerClick_app ВЫЗВАН для маркера #' num2str(idx) ' ---']);
        if confirmed_app || current_ui_state ~= STATE_MARKING_POINTS
             disp('DEBUG: onMarkerClick_app: Выход.'); return;
        end
        editingIndex_app = idx; 
        title(axImage,sprintf('Редактирование точки #%d: кликните новое место',idx));
        disp(['DEBUG: onMarkerClick_app: Установлен editingIndex_app = ' num2str(idx)]);
    end

    function fix_points_callback(~,~)
        disp('--- DEBUG: fix_points_callback ВЫЗВАН ---');
        if isempty(selectedPoints_app)
            disp('DEBUG: fix_points_callback: Нет точек.');
            set(hStatusTextOverall, 'String', 'Нет точек для закрепления.'); return; % Используем String
        end
        confirmed_app = true; 
        editingIndex_app = 0; 
        title(axImage,sprintf('Точки (%d шт.) закреплены. Готово к сканированию.', size(selectedPoints_app,1)));
        set(hStatusTextOverall, 'String', sprintf('Точки (%d шт.) закреплены.', size(selectedPoints_app,1))); % Используем String
        if ~isempty(hImg_app) && ishandle(hImg_app) && isvalid(hImg_app)
             set(hImg_app, 'ButtonDownFcn', ''); 
        end 
        arrayfun(@(m) set(m, 'ButtonDownFcn', ''), markers_app(isgraphics(markers_app))); 
        update_ui_for_state(STATE_POINTS_FIXED); 
        disp('--- DEBUG: fix_points_callback ЗАВЕРШЕН ---');
    end
    
    function start_sequence_scan_callback(~, ~)
        disp('--- DEBUG: start_sequence_scan_callback ВЫЗВАН ---');
        if isempty(tcp_client) || ~isequal(tcp_client.Status, 'open')
            errordlg('Нет TCP соединения с датчиком.', 'Ошибка'); 
            disp('DEBUG: start_sequence_scan_callback: Нет TCP соединения.');
            return; 
        end
        if isempty(scan_data_internal) || ~confirmed_app
            errordlg('Точки не размечены или не закреплены.', 'Ошибка'); 
            disp('DEBUG: start_sequence_scan_callback: Точки не размечены/не закреплены.');
            return; 
        end
        
        disp('DEBUG: start_sequence_scan_callback: Начало процесса сканирования.');
        update_ui_for_state(STATE_SEQUENCE_SCANNING); 
        isScanning_process_active = true;
        
        points_to_scan_indices = sort(scan_data_internal(:,1)); 
        original_timeout = tcp_client.Timeout; 
        tcp_client.Timeout = 60; 

        for i = 1:length(points_to_scan_indices)
            if ~isScanning_process_active
                disp('DEBUG: start_sequence_scan_callback: Сканирование прервано пользователем (флаг).');
                break; 
            end 
            current_point_idx_val = points_to_scan_indices(i);
            current_point_being_scanned_index_val = current_point_idx_val; 
            update_points_on_image_app(); 
            row_in_data = find(scan_data_internal(:,1) == current_point_idx_val, 1);
            if isempty(row_in_data)
                disp(['DEBUG: start_sequence_scan_callback: Пропуск точки, не найдена в scan_data_internal: ' num2str(current_point_idx_val)]);
                continue; 
            end
            set(hInstructionText, 'String', sprintf('Сканируется точка %d из %d. Наведите датчик...', current_point_idx_val, length(points_to_scan_indices))); % ИСПРАВЛЕНО
            set(hStatusTextOverall, 'String', sprintf('Сканирование точки %d: Ожидание объекта...', current_point_idx_val)); % ИСПРАВЛЕНО
            drawnow; 

            perform_scan_for_point(current_point_idx_val, false); 
            
            if isnan(scan_data_internal(row_in_data, 4)) 
                if isScanning_process_active 
                     set(hStatusTextOverall, 'String', sprintf('Ошибка/нет данных на точке %d.', current_point_idx_val));  % ИСПРАВЛЕНО
                     choice = questdlg(sprintf('Ошибка/нет данных на точке %d. Прервать сканирование?', current_point_idx_val), ...
                                       'Ошибка сканирования', 'Прервать', 'Продолжить (пропустить)', 'Продолжить (пропустить)');
                     if strcmp(choice, 'Прервать')
                         isScanning_process_active = false; 
                         disp('DEBUG: start_sequence_scan_callback: Пользователь выбрал "Прервать" после ошибки данных.');
                         break; 
                     end
                end
            end
            if i < length(points_to_scan_indices) && isScanning_process_active, pause(0.2); end 
        end

        if ishandle(tcp_client) && strcmp(tcp_client.Status, 'open') 
            tcp_client.Timeout = original_timeout; 
        end
        current_point_being_scanned_index_val = 0; 
        update_points_on_image_app(); 
        
        if isScanning_process_active 
            set(hStatusTextOverall, 'String', 'Сканирование всех точек завершено.');  % ИСПРАВЛЕНО
            set(hInstructionText, 'String', 'Сканирование завершено.'); % ИСПРАВЛЕНО
            disp('DEBUG: start_sequence_scan_callback: Сканирование завершено успешно.');
        else 
            set(hStatusTextOverall, 'String', 'Сканирование остановлено/прервано.');  % ИСПРАВЛЕНО
            set(hInstructionText, 'String', 'Сканирование прервано.'); % ИСПРАВЛЕНО
             disp('DEBUG: start_sequence_scan_callback: Сканирование было остановлено/прервано.');
        end
        isScanning_process_active = false; 
        update_ui_for_state(STATE_POINTS_FIXED); 
        disp('--- DEBUG: start_sequence_scan_callback ЗАВЕРШЕН ---');
    end
    
    function stop_sequence_scan_callback(~,~)
        disp('--- DEBUG: stop_sequence_scan_callback ВЫЗВАН ---');
        if isScanning_process_active
            isScanning_process_active = false; 
            set(hStatusTextOverall, 'String', 'Остановка сканирования...');  % ИСПРАВЛЕНО
            set(hInstructionText, 'String', 'Остановка...'); % ИСПРАВЛЕНО
            
            if ~isempty(tcp_client) && strcmp(tcp_client.Status, 'open')
                try
                    % ЗАМЕНИТЕ 'ABORT_SCAN' НА РЕАЛЬНУЮ КОМАНДУ ДЛЯ ВАШЕГО ДАТЧИКА
                    disp('DEBUG: (Условно) Отправка команды ABORT_SCAN датчику для сброса/завершения.');
                catch ME_abort
                    disp(['ПРЕДУПРЕЖДЕНИЕ: Ошибка при отправке команды ABORT_SCAN датчику: ' ME_abort.message]);
                end
            end
        else
            disp('DEBUG: stop_sequence_scan_callback: Сканирование не было активно.');
        end
    end

    function rescan_point_callback(~,~)
        if current_ui_state == STATE_SEQUENCE_SCANNING, set(hStatusTextOverall, 'String', 'Дождитесь завершения сканирования.'); return; end % Используем String
        if isempty(selected_table_row_for_rescan), set(hStatusTextOverall, 'String', 'Выберите точку в таблице.'); return; end % Используем String
        if isempty(tcp_client) || ~isequal(tcp_client.Status, 'open'), errordlg('Нет TCP соединения с датчиком.', 'Ошибка'); return; end
        row_idx_in_data_to_rescan = selected_table_row_for_rescan; 
        if row_idx_in_data_to_rescan > size(scan_data_internal,1) || row_idx_in_data_to_rescan < 1, set(hStatusTextOverall, 'String', 'Неверный индекс строки.'); return; end % Используем String
        point_idx_to_rescan_val = scan_data_internal(row_idx_in_data_to_rescan, 1);
        if isnan(point_idx_to_rescan_val) || point_idx_to_rescan_val <= 0, set(hStatusTextOverall, 'String', 'Неверный PointIndex.'); return; end % Используем String
        x_coord = scan_data_internal(row_idx_in_data_to_rescan, 2); y_coord = scan_data_internal(row_idx_in_data_to_rescan, 3);
        prev_state_before_rescan = current_ui_state; update_ui_for_state(STATE_SEQUENCE_SCANNING); set(hStopSequenceScanButton, 'Enable',false); 
        set(hStatusTextOverall, 'String', sprintf('Пересъем точки %d (%s,%s). Ожидание...', point_idx_to_rescan_val, num2str(x_coord), num2str(y_coord) )); % Используем String
        current_point_being_scanned_index_val = point_idx_to_rescan_val; update_points_on_image_app(); 
        original_timeout = tcp_client.Timeout; tcp_client.Timeout = 60;
        perform_scan_for_point(point_idx_to_rescan_val, true); 
        tcp_client.Timeout = original_timeout; current_point_being_scanned_index_val = 0; update_points_on_image_app(); 
        update_ui_for_state(prev_state_before_rescan); 
        if isnan(scan_data_internal(row_idx_in_data_to_rescan,4)), set(hStatusTextOverall, 'String', sprintf('Ошибка пересъема точки %d.', point_idx_to_rescan_val)); % Используем String
        else, set(hStatusTextOverall, 'String', sprintf('Точка %d переснята: %.3f V.', point_idx_to_rescan_val, scan_data_internal(row_idx_in_data_to_rescan,4))); end % Используем String
    end

    function perform_scan_for_point(point_idx_value, is_manual_or_rescan)
        current_voltage = NaN; row_in_data = find(scan_data_internal(:,1) == point_idx_value, 1);
        if isempty(row_in_data), set(hStatusTextOverall, 'String', ['Ошибка: точка ' num2str(point_idx_value) ' не найдена.']); return; end % Используем String
        try
            active_scan_flag = isScanning_process_active || is_manual_or_rescan; 
            if ~active_scan_flag, scan_data_internal(row_in_data, 4) = NaN; update_table_and_plot(); return; end
            if ~is_manual_or_rescan && ~isScanning_process_active, scan_data_internal(row_in_data, 4) = NaN; update_table_and_plot(); return; end
            writeline(tcp_client, 'ARM_SCAN'); ack = readline(tcp_client); ack = strtrim(ack);
            if ~strcmpi(ack, 'ARMED')
                error_msg = 'Датчик не подтвердил ARM_SCAN.'; if ~isempty(ack), error_msg = [error_msg ' Ответ: ' ack]; end
                if ~is_manual_or_rescan && isScanning_process_active, error(error_msg); else, errordlg(error_msg, 'Ошибка ARM датчика'); end
                scan_data_internal(row_in_data, 4) = NaN; update_table_and_plot(); return;
            end
            if ~is_manual_or_rescan && ~isScanning_process_active, scan_data_internal(row_in_data, 4) = NaN; update_table_and_plot(); return; end
            status_string_current = get(hStatusTextOverall,'String'); 
            if ~contains(status_string_current, 'Датчик готов'), set(hStatusTextOverall, 'String', [status_string_current ' Датчик готов. Ждем триггер...']); drawnow; end % Используем String
            voltage_str = readline(tcp_client); voltage_str = strtrim(voltage_str); current_voltage = str2double(voltage_str);
            if isnan(current_voltage)
                error_msg = 'Неверные данные от датчика.'; if ~isempty(voltage_str), error_msg = [error_msg ' Ответ: ' voltage_str]; end
                if ~is_manual_or_rescan && isScanning_process_active, error(error_msg); else, errordlg(error_msg, 'Ошибка данных от датчика'); end
            end
        catch ME
            disp(['Scan error point ' num2str(point_idx_value) ': ' ME.message]); current_voltage = NaN; 
            if is_manual_or_rescan || (~is_manual_or_rescan && ~isScanning_process_active), errordlg(['Scan error: ' ME.message], 'Ошибка сканирования'); end
        end
        scan_data_internal(row_in_data, 4) = current_voltage;
        update_table_and_plot(); 
    end
    
    function update_points_on_image_app()
        if ~ishandle(axImage) || ~isvalid(axImage), return; end 
        delete(markers_app(isgraphics(markers_app))); markers_app = gobjects(0);
        delete(labels_app(isgraphics(labels_app)));  labels_app  = gobjects(0);
        if isempty(selectedPoints_app), return; end 
        axes(axImage); 
        hold(axImage,'on');
        for k_app = 1:size(selectedPoints_app,1)
            x_app = selectedPoints_app(k_app,1); y_app = selectedPoints_app(k_app,2);
            point_idx_val_app = k_app; 
            marker_color_app = 'r'; marker_size_app = 8;
            if point_idx_val_app == current_point_being_scanned_index_val, marker_color_app = 'g'; marker_size_app = 12; end
            marker_bdfcn_app = ''; if ~confirmed_app, marker_bdfcn_app = @(s,e)onMarkerClick_app(s,point_idx_val_app,e); end 
            m_app = plot(axImage,x_app,y_app,'o', 'MarkerEdgeColor','k', 'MarkerFaceColor',marker_color_app,'MarkerSize',marker_size_app, 'ButtonDownFcn',marker_bdfcn_app);
            markers_app(point_idx_val_app) = m_app;
            lbl_app = text(x_app+POINT_LABEL_OFFSET_X, y_app+POINT_LABEL_OFFSET_Y, num2str(point_idx_val_app), ...
                           'Parent', axImage, 'Color','blue','FontWeight','bold', 'PickableParts','none'); 
            labels_app(point_idx_val_app) = lbl_app;
        end
        hold(axImage,'off');
    end

    function update_table_and_plot() 
        if ~ishandle(hScanDataTable) || ~ishandle(axScanPlot), return; end
        table_display_data = cell(size(scan_data_internal,1), 4);
        if ~isempty(scan_data_internal)
            [~, sort_order_table] = sort(scan_data_internal(:,1));
            sorted_scan_data_for_table = scan_data_internal(sort_order_table,:);
            for r_idx = 1:size(sorted_scan_data_for_table,1)
                table_display_data{r_idx,1} = sorted_scan_data_for_table(r_idx,1); 
                table_display_data{r_idx,2} = round(sorted_scan_data_for_table(r_idx,2),1); 
                table_display_data{r_idx,3} = round(sorted_scan_data_for_table(r_idx,3),1); 
                if ~isnan(sorted_scan_data_for_table(r_idx,4)), table_display_data{r_idx,4} = sprintf('%.4f', sorted_scan_data_for_table(r_idx,4));
                else, table_display_data{r_idx,4} = ''; end
            end
        end
        set(hScanDataTable, 'Data', table_display_data);
        if ~isempty(hPlotScan_internal) && isvalid(hPlotScan_internal), delete(hPlotScan_internal); end
        cla(axScanPlot); 
        if ~isempty(scan_data_internal)
            valid_scan_pts = scan_data_internal(:,1) > 0 & ~isnan(scan_data_internal(:,4));
            if any(valid_scan_pts)
                indices_plot = scan_data_internal(valid_scan_pts,1); voltages_plot = scan_data_internal(valid_scan_pts,4);
                [sorted_indices, sort_order_plot] = sort(indices_plot); sorted_voltages = voltages_plot(sort_order_plot);
                hPlotScan_internal = plot(axScanPlot, sorted_indices, sorted_voltages, 'b-o');
                if ~isempty(sorted_indices)
                    xlim_min = 0.5; xlim_max = max(max(sorted_indices),1) + 0.5;
                    if xlim_min >= xlim_max, xlim_max = xlim_min + 1; end 
                    xlim(axScanPlot, [xlim_min xlim_max]);
                end
            end
        end
        xlabel(axScanPlot, 'Номер точки'); ylabel(axScanPlot, 'Напряжение (V)'); grid(axScanPlot, 'on'); 
        drawnow limitrate; 
    end

    function table_cell_select_callback_app(~, event) 
        if current_ui_state == STATE_SEQUENCE_SCANNING, return; end 
        if ~isempty(event.Indices) && size(event.Indices,1) == 1 
            selected_row_in_display = event.Indices(1,1); 
            if isempty(scan_data_internal), selected_table_row_for_rescan = []; set(hRescanButton, 'Enable', 'off'); return; end
            table_data = get(hScanDataTable, 'Data'); 
            if selected_row_in_display > 0 && selected_row_in_display <= size(table_data,1)
                point_index_val_from_table_cell = table_data{selected_row_in_display, 1};
                if ischar(point_index_val_from_table_cell) && isempty(point_index_val_from_table_cell), point_index_val_from_table = NaN; 
                else, point_index_val_from_table = point_index_val_from_table_cell; end
                if isnumeric(point_index_val_from_table) && ~isnan(point_index_val_from_table) 
                    original_row_idx = find(scan_data_internal(:,1) == point_index_val_from_table, 1);
                    if ~isempty(original_row_idx), selected_table_row_for_rescan = original_row_idx; set(hRescanButton, 'Enable', 'on');
                        set(hStatusTextOverall, 'String', sprintf('Точка %d выбрана для пересъема.', point_index_val_from_table)); return; % Используем String
                    end
                end
            end
        end
        selected_table_row_for_rescan = []; set(hRescanButton, 'Enable', 'off');
    end
    
    function close_tcp_connection() 
        if ~isempty(tcp_client), try clear tcp_client; catch ME_close, disp(['TCP close error: ' ME_close.message]); end, tcp_client = []; disp('TCP connection closed.'); end
    end

    function finish_button_callback(~, ~) 
        if ~isempty(scan_data_internal)
            valid_rows = scan_data_internal(:,1) > 0 & ~isnan(scan_data_internal(:,4)); 
            if any(valid_rows), [~, sort_order_finish] = sort(scan_data_internal(valid_rows,1)); data_to_output = scan_data_internal(valid_rows,:);
                data_table_out = array2table(data_to_output(sort_order_finish,:), 'VariableNames', {'PointIndex', 'X', 'Y', 'Voltage'});
            else, data_table_out = cell2table(cell(0,4), 'VariableNames', {'PointIndex', 'X', 'Y', 'Voltage'}); end
        else, data_table_out = cell2table(cell(0,4), 'VariableNames', {'PointIndex', 'X', 'Y', 'Voltage'}); end
        close_fig_callback();
    end

    function close_fig_callback(~, ~) 
        isScanning_process_active = false; close_tcp_connection();
        if ishandle(hFig) && isvalid(hFig), delete(hFig); end
    end
end

simple_camera_capture_ui.m

function captured_image = simple_camera_capture_ui()
% SIMPLE_CAMERA_CAPTURE_UI Opens a separate dialog for live camera preview and frame capture.
% Returns the captured image, or an empty array if cancelled/failed.

    captured_image = []; % Default return

    % Initialize camera using the main helper function (assuming +camera package)
    % Ensure camera.capture_frame is accessible
    try
        cam_obj = camera.capture_frame('init');
    catch ME_init_pkg
        % Fallback if +camera package is not setup but capture_frame.m is directly on path
        warning('Could not call camera.capture_frame, trying direct capture_frame call for init.');
        try
            cam_obj = capture_frame('init');
        catch ME_init_direct
             errordlg(sprintf('Failed to initialize camera via camera.capture_frame or capture_frame:\n%s\n%s', ME_init_pkg.message, ME_init_direct.message), 'Camera Init Error');
             return;
        end
    end
    
    if isempty(cam_obj)
        errordlg('Не удалось инициализировать камеру.', 'Ошибка камеры');
        return;
    end

    % Create dialog
    screen_size = get(0, 'ScreenSize');
    
    % Attempt to get camera resolution for dialog sizing
    try
        pause(0.1); % Brief pause for properties to populate
        resStr = char(cam_obj.Resolution); 
        dims = sscanf(resStr, '%dx%d');
        img_width = dims(1); 
        img_height = dims(2);
    catch
        warning('Could not retrieve camera resolution. Using default 640x480 for dialog sizing.');
        img_width = 640;
        img_height = 480;
    end

    dlg_width = img_width + 40;  % Image width + padding
    dlg_height = img_height + 60 + 40; % Image height + button area + padding
    dlg_pos = [(screen_size(3)-dlg_width)/2, (screen_size(4)-dlg_height)/2, dlg_width, dlg_height];

    hDlg = dialog('Name', 'Захват кадра с камеры', ...
                  'Position', dlg_pos, ...
                  'Units', 'pixels', ... % Ensure units are pixels for positioning
                  'WindowStyle', 'modal', ...
                  'CloseRequestFcn', @cancel_button_callback, ...
                  'Visible', 'off'); % Create invisible, then adjust and make visible

    axCamDlg = axes('Parent', hDlg, 'Units', 'pixels', ...
                    'Position', [20, 70, img_width, img_height]); % x, y, w, h
    set(axCamDlg, 'XTick', [], 'YTick', []);
    
    hImageDlg = image(axCamDlg, uint8(zeros(img_height, img_width, 3))); % Placeholder
    axis(axCamDlg, 'image'); % Maintain aspect ratio

    % Adjust dialog and axes to actual image dimensions if possible
    set(hDlg, 'Position', [(screen_size(3)-dlg_width)/2, (screen_size(4)-dlg_height)/2, dlg_width, dlg_height]);
    set(hDlg, 'Visible', 'on'); % Now make it visible

    % Start preview in the dialog's image object
    try
        preview(cam_obj, hImageDlg); % Direct call to webcam object's preview method
    catch ME_preview
        errordlg(sprintf('Ошибка запуска предпросмотра: %s', ME_preview.message), 'Ошибка предпросмотра');
        cleanup_and_close_dialog(cam_obj, hDlg, true); % Pass true to indicate error state
        return;
    end

    uicontrol('Parent', hDlg, 'Style', 'pushbutton', ...
              'String', 'Зафиксировать кадр', ...
              'FontSize', 10, ...
              'Units', 'pixels', ...
              'Position', [dlg_width/2 - 100, 20, 200, 30], ... % Centered button
              'Callback', @fix_frame_button_callback);

    dialog_data.cam_obj = cam_obj;
    dialog_data.captured_image = []; % Initialize
    guidata(hDlg, dialog_data);

    uiwait(hDlg); % Block execution until uiresume or dialog is deleted

    if ishandle(hDlg) % Check if dialog still exists
        final_dialog_data = guidata(hDlg);
        if isfield(final_dialog_data, 'captured_image')
            captured_image = final_dialog_data.captured_image;
        end
        delete(hDlg); 
    end

    % Nested callbacks
    function fix_frame_button_callback(src, ~)
        fig_handle = ancestor(src, 'figure'); % Get dialog figure handle
        dlg_data_local = guidata(fig_handle); 
        
        if isempty(dlg_data_local) || ~isfield(dlg_data_local, 'cam_obj') || ...
           ~isvalid(dlg_data_local.cam_obj)
            disp('Ошибка: объект камеры не найден в диалоге при фиксации.');
            uiresume(fig_handle); % Unblock to allow cleanup
            return;
        end
        
        try
            snapshot_img = snapshot(dlg_data_local.cam_obj);
            dlg_data_local.captured_image = snapshot_img;
            guidata(fig_handle, dlg_data_local);
        catch ME_snap
            errordlg(sprintf('Ошибка захвата кадра: %s', ME_snap.message),'Ошибка');
            dlg_data_local.captured_image = []; % Ensure empty on error
            guidata(fig_handle, dlg_data_local); 
        end
        
        % Camera is released by cleanup_and_close_dialog after uiresume
        uiresume(fig_handle); 
    end

    function cancel_button_callback(src, ~)
        fig_handle = ancestor(src, 'figure'); % Get dialog figure handle
        dlg_data_local = guidata(fig_handle);
        
        % Ensure captured_image is empty if cancelled
        if ~isempty(dlg_data_local)
            dlg_data_local.captured_image = [];
            guidata(fig_handle, dlg_data_local);
        end
        
        % Camera is released by cleanup_and_close_dialog after uiresume
        uiresume(fig_handle);
    end
    
    % Centralized cleanup for the dialog's camera object
    function cleanup_and_close_dialog(camera_object, dialog_handle, in_error_state)
        if nargin < 3, in_error_state = false; end
        if ~isempty(camera_object) && isvalid(camera_object)
            disp('SimpleCameraUI: Releasing camera object...');
            try
                % Use the main helper function to clear (assumes +camera package)
                camera.capture_frame('clear'); 
            catch ME_clear_pkg
                warning('Could not call camera.capture_frame, trying direct capture_frame call for clear.');
                try
                    capture_frame('clear');
                catch ME_clear_direct
                    fprintf(2,'SimpleCameraUI: Failed to clear camera via helper: %s\n%s\n',ME_clear_pkg.message, ME_clear_direct.message);
                end
            end
        end
        if ishandle(dialog_handle)
            if in_error_state % If called due to an error, we might need to force uiresume if uiwait is active
                if strcmp(get(dialog_handle, 'BeingDeleted'), 'off') % Check if not already being deleted
                    uiresume(dialog_handle); % Try to unblock uiwait
                end
            end
           % delete(dialog_handle) will be handled by the main function after uiwait
        end
    end

    % Final cleanup call for the camera object associated with this dialog
    % This runs after uiwait has finished, regardless of how it finished.
    cleanup_and_close_dialog(cam_obj, hDlg, false);

end

+camera/capture_frame.m

function varargout = capture_frame(action, varargin)
% CAPTURE_FRAME Manages webcam operations: init, preview, snapshot, clear.
% (Using MATLAB's modern 'webcam' objects)

persistent hFigPreview_internal % Persistent handle for internal preview window

varargout = {}; % Default empty output
base_cam_var_name = 'camera_object_managed_by_capture_frame'; % Consistent name

switch lower(action)
    case 'init'
        current_cam_obj = [];
        if evalin('base', sprintf("exist('%s', 'var')", base_cam_var_name))
            current_cam_obj = evalin('base', base_cam_var_name);
            if ~isvalid(current_cam_obj) || ~isa(current_cam_obj, 'webcam')
                fprintf('[capture_frame] Existing %s is invalid or not a webcam. Re-initializing.\n', base_cam_var_name);
                current_cam_obj = [];
            else
                disp('[capture_frame] Using existing valid webcam object from base workspace.');
            end
        end

        if isempty(current_cam_obj)
            try
                camList = webcamlist;
                if isempty(camList)
                    error('No webcams detected. Check connections/drivers and MATLAB Support Package for USB Webcams.');
                end
                fprintf('[capture_frame] Initializing webcam: %s\n', camList{1});
                current_cam_obj = webcam(1); % Use the first webcam
                assignin('base', base_cam_var_name, current_cam_obj);
                disp(['[capture_frame] New webcam object created and stored as ', base_cam_var_name]);
            catch ME
                errordlg(sprintf('[capture_frame] Error initializing webcam: %s', ME.message), 'Webcam Init Error');
                current_cam_obj = [];
            end
        end
        varargout{1} = current_cam_obj;

    case 'start_preview' % For GUI image handle
        if nargin < 2 % action, imgHandle, [cam_obj_optional]
            error('[capture_frame] Not enough arguments for start_preview. Need image handle.');
        end
        imgHandle = varargin{1}; % Image handle IS used
        
        cam_obj = [];
        if nargin > 2 && ~isempty(varargin{2}) && isa(varargin{2}, 'webcam') && isvalid(varargin{2})
            cam_obj = varargin{2};
        elseif evalin('base', sprintf("exist('%s', 'var')", base_cam_var_name))
            base_obj = evalin('base', base_cam_var_name);
            if isa(base_obj, 'webcam') && isvalid(base_obj)
                cam_obj = base_obj;
            end
        end

        if ~isempty(cam_obj)
            try
                preview(cam_obj, imgHandle); % This starts the live update to imgHandle
                disp('[capture_frame] Preview started on provided image handle.');
            catch ME
                errordlg(sprintf('[capture_frame] Error starting preview: %s', ME.message), 'Preview Error');
            end
        else
            warning('[capture_frame] No valid camera object found to start preview.');
        end

    case 'stop_preview' % Mainly for internal preview window cleanup
        disp('[capture_frame] ''stop_preview'' action called (primarily for internal preview cleanup).');
        if ~isempty(hFigPreview_internal) && ishandle(hFigPreview_internal)
            try 
                disp('[capture_frame] Closing internal snapshot preview window.');
                delete(hFigPreview_internal); 
            catch ME_closing_internal
                fprintf(2, '[capture_frame] Error closing internal preview: %s\n', ME_closing_internal.message);
            end
            hFigPreview_internal = [];
        else
            %disp('[capture_frame] No internal snapshot preview window to close.');
        end
        % Actual stopping of preview on a GUI handle is done by deleting the webcam object
        % or by the GUI no longer allowing updates / replacing the image content.

    case 'snapshot'
        show_internal_preview = false;
        if nargin > 1 && islogical(varargin{1})
            show_internal_preview = varargin{1};
        end
        
        cam_obj = [];
        idx = 1; if islogical(varargin{1}), idx=2; end % Adjust index if show_internal_preview was passed

        if nargin > idx && ~isempty(varargin{idx}) && isa(varargin{idx},'webcam') && isvalid(varargin{idx})
            cam_obj = varargin{idx};
        elseif evalin('base', sprintf("exist('%s', 'var')", base_cam_var_name))
            base_obj = evalin('base', base_cam_var_name);
            if isa(base_obj, 'webcam') && isvalid(base_obj)
                cam_obj = base_obj;
            end
        end
        
        if isempty(cam_obj)
            disp('[capture_frame] Camera not initialized for snapshot. Initializing now.');
            cam_obj = camera.capture_frame('init'); % Ensure package notation if used
            if isempty(cam_obj), varargout{1} = []; return; end
        end
        
        img = [];
        if ~isempty(cam_obj) && isvalid(cam_obj)
            if show_internal_preview
                if ~isempty(hFigPreview_internal) && ishandle(hFigPreview_internal)
                    try delete(hFigPreview_internal); catch; end
                end
                hFigPreview_internal = figure('Name', 'Camera Preview - Close to Capture', ...
                                            'NumberTitle', 'off', 'CloseRequestFcn', 'uiresume(gcbf)');
                try
                    img_for_prev = snapshot(cam_obj);
                    imshow(img_for_prev, 'Parent',gca);
                    title('Close this window to capture frame');
                    uiwait(hFigPreview_internal);
                catch ME_internal_prev
                    errordlg(sprintf('[capture_frame] Error during internal preview: %s', ME_internal_prev.message),'Internal Preview Error');
                    if ishandle(hFigPreview_internal), delete(hFigPreview_internal); end
                    hFigPreview_internal = []; varargout{1} = []; return;
                end
                if ishandle(hFigPreview_internal), delete(hFigPreview_internal); end
                hFigPreview_internal = []; 
            end
            
            try
                img = snapshot(cam_obj);
                disp('[capture_frame] Snapshot taken.');
            catch ME
                errordlg(sprintf('[capture_frame] Error taking snapshot: %s', ME.message), 'Snapshot Error');
                img = [];
            end
        else
            warning('[capture_frame] No valid camera object for snapshot.'); img = [];
        end
        varargout{1} = img;

    case 'clear'
        disp('[capture_frame] ''clear'' action called.');
        cam_obj_to_clear = [];
        if evalin('base', sprintf("exist('%s', 'var')", base_cam_var_name))
            cam_obj_to_clear = evalin('base', base_cam_var_name);
            if isa(cam_obj_to_clear, 'webcam') && isvalid(cam_obj_to_clear)
                disp(['[capture_frame] Deleting webcam object: ', get(cam_obj_to_clear, 'Name')]);
                delete(cam_obj_to_clear); % This stops any preview it was managing
            else
                disp('[capture_frame] Object in base was not a valid webcam or already invalid.');
            end
            evalin('base', sprintf("clear %s", base_cam_var_name));
            disp(['[capture_frame] Cleared ', base_cam_var_name, ' from base workspace.']);
        else
            disp('[capture_frame] No base workspace variable to clear.');
        end

        if ~isempty(hFigPreview_internal) && ishandle(hFigPreview_internal)
            try delete(hFigPreview_internal); catch; end
            hFigPreview_internal = [];
        end
    otherwise
        error('[capture_frame] Unknown action: %s.', action);
end
end

ir_sensor/ir_scan_callback.m

function ir_scan_callback(hObject,~)
    handles = guidata(hObject);
    if ~isfield(handles, 'axPlot')
        errordlg('Не удалось найти ось для графика ИК-данных (axPlot) в handles.', 'Ошибка GUI');
        return;
    end
    if ~isfield(handles, 'hFig')
        current_fig = gcbf; 
        if isempty(current_fig) && ishandle(hObject)
            current_fig = ancestor(hObject, 'figure');
        end
        if isempty(current_fig)
            errordlg('Не удалось найти главный figure handle (hFig).', 'Ошибка GUI');
            return;
        else
            handles.hFig = current_fig; 
        end
    end

    persistent esp_ip_address_cached;

    % --- НАСТРОЙКИ ESP8266 ---
    esp_port_tcp = 8888; % TCP порт, указанный в скетче ESP для MATLAB
    % -------------------------

    if isempty(esp_ip_address_cached) || strcmp(esp_ip_address_cached, 'YOUR_ESP_IP_ADDRESS')
        prompt = {'Введите IP адрес ESP8266:'};
        dlgtitle = 'IP адрес ИК-сканера';
        dims = [1 40];
        definput = {'192.168.0.227'}; % Замените на IP вашего ESP
        answer = inputdlg(prompt,dlgtitle,dims,definput);
        if isempty(answer) || isempty(answer{1})
            disp('IP адрес не введен. Операция ИК-сканирования отменена.');
            title(handles.axPlot, 'ИК-сканирование отменено (нет IP)');
            return;
        end
        esp_ip_address_cached = strtrim(answer{1});
    end
    
    esp_ip_address = esp_ip_address_cached;

    cla(handles.axPlot);
    title(handles.axPlot, 'Подключение к ИК-сканеру (MATLAB)...', 'FontSize', 10);
    drawnow;

    tcp_client = []; 

    try
        fprintf('Попытка подключения к ESP (MATLAB TCP): %s:%d\n', esp_ip_address, esp_port_tcp);
        tcp_client = tcpclient(esp_ip_address, esp_port_tcp, 'Timeout', 7, 'ConnectTimeout', 7); % Таймауты можно подстроить
        configureTerminator(tcp_client, "LF");

        title(handles.axPlot, 'Отправка команды SCAN...', 'FontSize', 10);
        drawnow;

        writeline(tcp_client, "SCAN");
        disp('Команда SCAN отправлена на ESP.');

        title(handles.axPlot, 'Ожидание ответа от сканера...', 'FontSize', 10);
        drawnow;
        
        tcp_client.Timeout = 10; 
        response_str = readline(tcp_client);
        response_str = strtrim(response_str); 
        fprintf('Получен ответ от ESP: "%s"\n', response_str);

        clear tcp_client; 
        disp('TCP соединение с ESP закрыто.');

        if isempty(response_str)
            errordlg('Сканер не вернул данные (пустой ответ). Убедитесь, что ESP в режиме MATLAB Control.', 'Ошибка ИК-сканера');
            title(handles.axPlot, 'Ошибка: Пустой ответ', 'FontSize', 10);
            return;
        end

        if startsWith(response_str, "ERROR:", "IgnoreCase", true)
            errordlg(sprintf('ESP сообщил об ошибке: %s. Убедитесь, что ESP в режиме "MATLAB Control" через веб-страницу.', response_str), 'Ошибка ESP');
            title(handles.axPlot, 'Ошибка от ESP', 'FontSize', 10);
            return;
        end
        
        ir_voltage = str2double(response_str);
            
        if isnan(ir_voltage)
            errordlg(sprintf('Не удалось распознать данные от сканера. Получено: "%s"', response_str), 'Ошибка парсинга ИК');
            title(handles.axPlot, 'Ошибка парсинга ответа', 'FontSize', 10);
            return;
        end

        if ir_voltage < 0 
            fprintf('[INFO] IR Scan (MATLAB): No valid measurement (Distance > 30mm or VL53L0X error).\n');
            cla(handles.axPlot);
            text(handles.axPlot, 0.5, 0.5, 'Нет ИК-измерения для MATLAB (объект >30мм или ошибка)', ...
                 'HorizontalAlignment', 'center', 'FontSize', 10, 'Color', 'red');
            set(handles.axPlot, 'XTick', [], 'YTick', []);
            title(handles.axPlot, 'Результат ИК-сканирования', 'FontSize', 10);
            if evalin('base', "exist('irData', 'var')"), evalin('base', "clear irData"); end
        else
            fprintf('[INFO] IR Scan Result (MATLAB): Voltage = %.3f V\n', ir_voltage);
            cla(handles.axPlot);
            text(handles.axPlot, 0.5, 0.5, sprintf('ИК напряжение: %.3f V', ir_voltage), ...
                 'HorizontalAlignment', 'center', 'FontSize', 14, 'FontWeight', 'bold');
            set(handles.axPlot, 'XTick', [], 'YTick', []);
            title(handles.axPlot, 'Результат ИК-сканирования', 'FontSize', 10);

            irSensorReading.voltage = ir_voltage;
            assignin('base','irData', irSensorReading);
            disp(['Сохранено irData.voltage = ' num2str(ir_voltage)]);
            
            if evalin('base', "exist('capturedFrame', 'var') && exist('recognitionLabel', 'var')")
                 if isfield(handles, 'hDigitalTwinButton') && isgraphics(handles.hDigitalTwinButton)
                    set(handles.hDigitalTwinButton, 'Enable', 'on');
                 end
            end
        end
        drawnow;

    catch ME
        errordlg(sprintf('Ошибка при связи с ИК-сканером (%s:%d):\n%s. Убедитесь, что ESP включен и в правильном режиме.', esp_ip_address, esp_port_tcp, ME.message), 'Ошибка связи ИК');
        title(handles.axPlot, 'Ошибка связи с ИК-сканером', 'FontSize', 10);
        if ~isempty(tcp_client) && isvalid(tcp_client), clear tcp_client; end 
        disp('TCP соединение с ESP закрыто из-за ошибки.');
        return;
    end
end

model/run_model.m

function [top_label_string, scores_vector, all_class_names] = run_model(image_matrix)
    % run_model: Performs image classification using a pre-trained and fine-tuned EfficientNet-B0 model.
    %
    % INPUTS:
    %   image_matrix: An RGB image matrix (e.g., uint8, uint16, double).
    %
    % OUTPUTS:
    %   top_label_string: String, the name of the most probable class. 'Ошибка' on error.
    %   scores_vector:    Numeric row vector of probabilities/scores for all classes. Empty on error.
    %   all_class_names:  Cell array of strings, names of all classes in the model's output order. Empty on error.

    top_label_string = 'Ошибка';
    scores_vector = [];
    all_class_names = {};

    persistent loaded_efficientnet_model; 

    try
        if isempty(loaded_efficientnet_model)
            disp('Загрузка дообученной модели EfficientNet-B0 (run_model.m)...');
            
            model_filename = 'skinDiseaseClassifier_03.mat'; 
            % Имя переменной, под которым сохранена ваша сеть в .mat файле
            neural_net_variable_name_in_file = 'trainedNet'; 
            
            model_filepath = fullfile('model', model_filename); 
            
            if ~exist(model_filepath, 'file')
                error_msg = sprintf('Файл модели ''%s'' не найден. Убедитесь, что он находится в папке ''model''.', model_filepath);
                disp(error_msg);
                errordlg(error_msg, 'Ошибка загрузки модели');
                return; 
            end
            
            loaded_data = load(model_filepath);

            if isfield(loaded_data, neural_net_variable_name_in_file)
                network_object = loaded_data.(neural_net_variable_name_in_file);
                % Проверка, что это действительно объект сети
                if (isa(network_object, 'SeriesNetwork') || isa(network_object, 'DAGNetwork') || ...
                    isa(network_object, 'dlnetwork') || isa(network_object, 'nnet.cnn.layer.LayerGraph'))
                    loaded_efficientnet_model = network_object;
                    disp(['Модель ''', model_filename, ''' (переменная ''', neural_net_variable_name_in_file, ''') успешно загружена.']);
                else
                    error_msg = sprintf('Переменная ''%s'' в файле ''%s'' не является ожидаемым объектом сети.', ...
                                        neural_net_variable_name_in_file, model_filename);
                    disp(error_msg);
                    errordlg(error_msg, 'Ошибка типа модели');
                    return;
                end
            else
                field_names_in_mat = fieldnames(loaded_data);
                error_msg = sprintf(['Ожидаемая переменная ''%s'' с нейросетью не найдена в файле ''%s''. ', ...
                                     'Найденные переменные: %s.'], ...
                                    neural_net_variable_name_in_file, model_filename, strjoin(field_names_in_mat, ', '));
                disp(error_msg);
                errordlg(error_msg, 'Ошибка загрузки модели');
                return; 
            end
        end

        current_net = loaded_efficientnet_model;

        % Извлечение имен классов
        % Для сетей, созданных с ClassificationLayer или OutputLayer в Deep Learning Toolbox
        if isprop(current_net, 'Layers') && isa(current_net.Layers(end), 'nnet.cnn.layer.ClassificationOutputLayer')
            all_class_names = current_net.Layers(end).ClassNames;
        elseif isprop(current_net, 'ClassNames') % Для некоторых других конфигураций или dlnetwork
            all_class_names = current_net.ClassNames;
        else
            warning('run_model: Не удалось автоматически извлечь ClassNames. Проверьте структуру вашей сети ''%s''.', neural_net_variable_name_in_file);
        end
        
        if isempty(all_class_names)
            error_msg = sprintf('Список классов пуст для модели ''%s''. Убедитесь, что у модели есть информация о классах.', neural_net_variable_name_in_file);
            disp(error_msg);
            errordlg(error_msg, 'Ошибка модели');
            return;
        end
        
        % Предобработка изображения для EfficientNet-B0
        try
            % EfficientNet-B0 обычно ожидает вход 224x224
            % Попытаемся получить размер из первого слоя, если он imageInputLayer
            expected_input_size = [224 224]; % По умолчанию для EfficientNet-B0
            if isprop(current_net.Layers(1), 'InputSize')
                layer_input_size = current_net.Layers(1).InputSize;
                if length(layer_input_size) >= 2
                    expected_input_size = [layer_input_size(1) layer_input_size(2)];
                    disp(['Используется InputSize из первого слоя модели: [', num2str(expected_input_size(1)), ' ', num2str(expected_input_size(2)), ']']);
                end
            else
                 disp('Первый слой модели не имеет свойства InputSize или не является imageInputLayer. Используется размер по умолчанию 224x224.');
            end
            
            % 1. Изменение размера
            image_resized = imresize(image_matrix, expected_input_size);
            
            % 2. Нормализация в диапазон [0, 1], если изображение целочисленное
            % EfficientNet часто обучается на данных, нормализованных таким образом
            % или с вычитанием среднего и делением на стандартное отклонение ImageNet.
            % Если ваша сеть имеет встроенный imageInputLayer с нормализацией, этот шаг может быть избыточным
            % или должен быть адаптирован.
            if isinteger(image_resized) % uint8, int16 и т.д.
                image_normalized = im2single(image_resized); % Преобразует в single и масштабирует в [0,1]
            elseif isa(image_resized, 'single') || isa(image_resized, 'double')
                % Если уже float, предполагаем, что оно либо в [0,1], либо уже нормализовано как надо.
                % Можно добавить проверку min/max и масштабировать, если нужно, но это зависит от ваших данных.
                if max(image_resized(:)) > 1.0 || min(image_resized(:)) < 0.0
                    disp('Предупреждение: Входное изображение типа float, но не в диапазоне [0,1]. Используется как есть.');
                end
                image_normalized = image_resized;
            else
                warning('Неизвестный тип данных изображения для нормализации. Попытка преобразовать в single.');
                image_normalized = single(image_resized); % Базовая попытка
            end
            
            % Если ваша сеть ожидает специфическую нормализацию ImageNet (вычитание среднего, деление на std),
            % это нужно делать здесь. Например:
            % mean_imagenet = [0.485, 0.456, 0.406];
            % std_imagenet = [0.229, 0.224, 0.225];
            % image_normalized = (image_normalized - reshape(mean_imagenet, [1 1 3])) ./ reshape(std_imagenet, [1 1 3]);

            image_for_classification = image_normalized;

        catch ME_preprocess
            error_msg = sprintf('Ошибка предобработки изображения для модели EfficientNet-B0: %s', ME_preprocess.message);
            disp(error_msg);
            errordlg(error_msg, 'Ошибка предобработки');
            return;
        end

        % Классификация
        if isa(current_net, 'dlnetwork')
            % Для dlnetwork может потребоваться predict, а не classify,
            % и scores могут быть ненормализованными логитами.
            % Если это так, вам нужно будет применить softmax к выходу.
            % Этот пример предполагает, что ваша dlnetwork была преобразована для classify
            % или имеет выходной слой, который позволяет использовать classify.
            % Если classify не работает, попробуйте:
            %   dlImg = dlarray(image_for_classification, 'SSCB'); % Или другой формат данных
            %   scores_raw = predict(current_net, dlImg);
            %   scores = softmax(extractdata(scores_raw))'; % scores должен быть строкой
            %   [~, max_idx] = max(scores);
            %   YPred = all_class_names(max_idx);
            % Этот блок ниже предполагает, что classify работает.
             [YPred, scores] = classify(current_net, image_for_classification);
        else % Для SeriesNetwork, DAGNetwork
            [YPred, scores] = classify(current_net, image_for_classification);
        end
        
        top_label_string = string(YPred);
        scores_vector = scores'; % Убедимся, что это вектор-строка

        if length(scores_vector) ~= length(all_class_names)
            error_msg = sprintf(['Несоответствие после классификации: количество баллов (%d) не совпадает с количеством классов (%d).'], ...
                                 length(scores_vector), length(all_class_names));
            disp(error_msg);
            errordlg(error_msg, 'Ошибка модели');
            top_label_string = 'Ошибка'; scores_vector = []; all_class_names = {}; 
            return;
        end

        % Отладочный вывод в терминал
        disp('--- Debug Output from run_model.m (EfficientNet-B0) ---');
        disp('Предсказанная метка (top_label_string):');
        disp(top_label_string);
        disp('Все имена классов (all_class_names) - в том же порядке, что и scores_vector:');
        disp(all_class_names);
        disp('Баллы/вероятности для каждого класса (scores_vector):');
        disp(scores_vector);
        if ~isempty(all_class_names) && ~isempty(scores_vector) && (length(all_class_names) == length(scores_vector))
            disp('Таблица "Класс - Вероятность":');
            try
                class_names_col = all_class_names(:); % Гарантированно столбец
                scores_col = scores_vector(:);       % Гарантированно столбец
                debug_table = table(class_names_col, scores_col, 'VariableNames', {'Class', 'Score'});
                disp(debug_table);
            catch ME_table_debug
                disp(['Не удалось создать отладочную таблицу: ', ME_table_debug.message]);
            end
        end
        disp('--- End of Debug Output from run_model.m ---');

    catch ME
        error_msg = sprintf('Критическая ошибка в run_model.m: %s', ME.message);
        disp(error_msg);
        fprintf(2, 'Источник ошибки в run_model.m: %s (строка %d)\n', ME.stack(1).name, ME.stack(1).line);
        errordlg(error_msg, 'Ошибка выполнения модели');
        top_label_string = 'Ошибка';
        scores_vector = [];
        all_class_names = {};
    end
end

model/skinDiseaseClassifier_03.mat

[Не удалось прочитать файл как текст (возможно, бинарный)]

utils/build_digital_twin.m

function build_digital_twin(scan_data_table, roi_image_for_boundaries, target_axes)
    % BUILD_DIGITAL_TWIN Generates a 3D interpolated surface plot ("digital twin")
    % from sparse IR scan data and displays it in the specified target axes.
    %
    % Args:
    %   scan_data_table: Table with columns 'X', 'Y', 'Voltage'.
    %   roi_image_for_boundaries: The 2D image (ROI) used for scanning.
    %                             Used to define plot boundaries. Can be empty.
    %   target_axes: Handle to the axes in the main GUI for plotting.

    disp('DEBUG (build_digital_twin): Function called.');

    % --- Input Validation ---
    if nargin < 3
        error('build_digital_twin:NotEnoughInputs', 'Requires scan_data_table, roi_image_for_boundaries, and target_axes.');
    end
    if ~ishandle(target_axes) || ~strcmp(get(target_axes, 'Type'), 'axes')
        error('build_digital_twin:InvalidTargetAxes', 'target_axes must be a valid axes handle.');
    end

    if isempty(scan_data_table) || ~istable(scan_data_table) || ...
       ~all(ismember({'X', 'Y', 'Voltage'}, scan_data_table.Properties.VariableNames))
        warning('build_digital_twin:InvalidScanData', 'Scan data is empty, not a table, or missing X, Y, Voltage columns.');
        cla(target_axes, 'reset');
        title(target_axes, 'Нет данных для 3D модели');
        text(target_axes, 0.5, 0.5, 'Данные ИК-сканирования отсутствуют или некорректны.', 'HorizontalAlignment', 'center');
        view(target_axes, 2); % Ensure 2D view if no data
        return;
    end

    valid_rows = ~isnan(scan_data_table.X) & ~isnan(scan_data_table.Y) & ~isnan(scan_data_table.Voltage);
    X = scan_data_table.X(valid_rows);
    Y = scan_data_table.Y(valid_rows);
    V = scan_data_table.Voltage(valid_rows);

    if numel(X) < 3 % Need at least 3 unique points for most 2D interpolations
        warning('build_digital_twin:NotEnoughPoints', 'Less than 3 valid data points for 3D surface interpolation.');
        cla(target_axes, 'reset');
        if numel(X) > 0
            % Plot points if available, but no surface
            scatter3(target_axes, X, Y, V, 50, V, 'filled');
            xlabel(target_axes, 'X (пикс.)');
            ylabel(target_axes, 'Y (пикс.)');
            zlabel(target_axes, 'Напряжение (V)');
            title(target_axes, 'Исходные точки (недостаточно для поверхности)');
            grid(target_axes, 'on');
            colorbar(target_axes);
            view(target_axes, 3);
        else
            title(target_axes, 'Нет валидных точек для 3D модели');
            text(target_axes, 0.5, 0.5, 'Нет валидных точек для построения.', 'HorizontalAlignment', 'center');
            view(target_axes, 2);
        end
        return;
    end
    
    % --- Determine Grid Boundaries ---
    if ~isempty(roi_image_for_boundaries) && isnumeric(roi_image_for_boundaries) && ndims(roi_image_for_boundaries) >= 2
        [img_height, img_width, ~] = size(roi_image_for_boundaries);
        x_lim_scan = [1, img_width];
        y_lim_scan = [1, img_height];
        disp('DEBUG (build_digital_twin): Grid boundaries from ROI image.');
    else
        % Fallback to data extents if no image
        x_lim_scan = [min(X), max(X)];
        y_lim_scan = [min(Y), max(Y)];
        % Add some padding if extents are too small
        if diff(x_lim_scan) == 0, x_lim_scan = x_lim_scan + [-1, 1]; end
        if diff(y_lim_scan) == 0, y_lim_scan = y_lim_scan + [-1, 1]; end
        disp('DEBUG (build_digital_twin): Grid boundaries from data extents.');
    end

    % --- Create Interpolation Grid ---
    % Adjust resolution based on the range of X and Y to avoid overly dense grids
    grid_points_x = max(50, min(200, round(diff(x_lim_scan)))); % Heuristic
    grid_points_y = max(50, min(200, round(diff(y_lim_scan))));
    if isempty(grid_points_x) || isnan(grid_points_x) || grid_points_x < 2, grid_points_x = 100; end
    if isempty(grid_points_y) || isnan(grid_points_y) || grid_points_y < 2, grid_points_y = 100; end


    [xq, yq] = meshgrid(linspace(x_lim_scan(1), x_lim_scan(2), grid_points_x), ...
                        linspace(y_lim_scan(1), y_lim_scan(2), grid_points_y));
    
    disp(['DEBUG (build_digital_twin): Interpolation grid size: X=' num2str(grid_points_x) ', Y=' num2str(grid_points_y)]);

    % --- Perform Interpolation ---
    % Using scatteredInterpolant for robustness with scattered data
    % 'natural' neighbor interpolation is often good for scattered data.
    % 'linear' is faster but may produce artifacts if points are not well distributed.
    F = scatteredInterpolant(X, Y, V, 'natural', 'none'); % 'none' for extrapolation gives NaN
    Vq = F(xq, yq);
    
    % Handle cases where all Vq might be NaN (e.g., points are collinear for linear, or too sparse)
    if all(isnan(Vq(:)))
        warning('build_digital_twin:InterpolationFailed', 'Interpolation resulted in all NaN values. Check data distribution.');
        cla(target_axes, 'reset');
        scatter3(target_axes, X, Y, V, 50, V, 'filled'); % Plot original points
        title(target_axes, 'Ошибка интерполяции (все NaN)');
        xlabel(target_axes, 'X (пикс.)'); ylabel(target_axes, 'Y (пикс.)'); zlabel(target_axes, 'Напряжение (V)');
        grid(target_axes, 'on'); colorbar(target_axes); view(target_axes, 3);
        return;
    end

    disp('DEBUG (build_digital_twin): Interpolation complete.');

    % --- Plotting ---
    cla(target_axes, 'reset'); % Reset axes for 3D plotting
    axes(target_axes); % Ensure target_axes is current

    surf(target_axes, xq, yq, Vq, 'EdgeColor', 'interp', 'FaceColor', 'interp');
    hold(target_axes, 'on');
    
    % Plot original scan points on top for reference
    plot3(target_axes, X, Y, V, 'k.', 'MarkerSize', 15); 
    
    hold(target_axes, 'off');

    % --- Appearance ---
    title(target_axes, '3D Карта Напряжения (Цифровой Двойник)');
    xlabel(target_axes, 'X координата (пикс.)');
    ylabel(target_axes, 'Y координата (пикс.)');
    zlabel(target_axes, 'Напряжение (V)');
    
    colormap(target_axes, 'jet'); % Or 'parula', 'hot', etc.
    hCb = colorbar(target_axes);
    ylabel(hCb, 'Напряжение (V)');
    
    grid(target_axes, 'on');
    axis(target_axes, 'tight'); % Fit axes to data
    
    % Set a good initial view and enable rotation
    view(target_axes, -37.5, 30); % Default 3D view azimuth and elevation
    rotate3d(target_axes, 'on');
    
    disp('DEBUG (build_digital_twin): 3D plot generated.');
end

utils/imblend.m

function out = imblend(im1, im2, alpha)
    out = uint8(alpha*double(im2) + (1-alpha)*double(im1));
end

utils/report_generator.m

function generate_report(~,~) % src argument is not used, can be ~
    % Retrieve data from base workspace
    try
        frame = evalin('base','capturedFrame');
        label = evalin('base','recognitionLabel'); % Changed from 'label'
        scores = evalin('base','recognitionScores'); % Changed from 'scores'
        irData = evalin('base','irData');
        twin = evalin('base','digitalTwin');
    catch ME
        errordlg(sprintf('Не удалось получить все необходимые данные из base workspace для отчета: %s\nУбедитесь, что все этапы (захват, распознавание, ИК, двойник) выполнены.', ME.message), 'Ошибка данных для отчета');
        return;
    end

    % Check if all necessary variables were actually retrieved and are not empty
    missingVars = {};
    if ~exist('frame','var') || isempty(frame), missingVars{end+1} = 'capturedFrame'; end
    if ~exist('label','var') || isempty(label), missingVars{end+1} = 'recognitionLabel'; end
    if ~exist('scores','var') || isempty(scores), missingVars{end+1} = 'recognitionScores'; end
    if ~exist('irData','var') || isempty(irData), missingVars{end+1} = 'irData'; end
    if ~exist('twin','var') || isempty(twin), missingVars{end+1} = 'digitalTwin'; end

    if ~isempty(missingVars)
        errordlg(sprintf('Для генерации отчета отсутствуют или пусты следующие данные: %s.', strjoin(missingVars, ', ')), 'Ошибка данных для отчета');
        return;
    end

    import mlreportgen.report.*;
    import mlreportgen.dom.*;

    try
        % Ensure the 'report' directory exists
        if ~isfolder('report')
            mkdir('report');
        end
        rpt = Report('report/diagnosis_report','pdf');
        
        % Title Page
        tp = TitlePage('Title','Отчет обследования кожных покровов');
        try
            currentUser = getenv('USERNAME'); % Windows
            if isempty(currentUser), currentUser = getenv('USER'); end % Linux/macOS
            if ~isempty(currentUser), tp.Author = currentUser; end
        catch
            % Silently ignore if username cannot be fetched
        end
        tp.PubDate = datestr(now, 'dd-mmm-yyyy HH:MM:SS');
        add(rpt, tp);
        
        % Classification Results Section
        secClassification = Section('Результаты классификации');
        paraTextStr = sprintf('Диагноз: %s', string(label));
        if isnumeric(scores) && ~isempty(scores) && numel(scores) > 0
             paraTextStr = [paraTextStr, sprintf(' (Вероятность наиболее вероятного класса: %.2f%%)', max(scores)*100)];
        end
        add(secClassification, Paragraph(paraTextStr));
        
        imgCapturedTitle = Paragraph('Захваченное изображение:');
        imgCapturedTitle.FontSize = '12pt';
        imgCapturedTitle.Bold = true;
        add(secClassification, imgCapturedTitle);
        
        figCaptured = Figure(Image(frame));
        figCaptured.SnapshotFormat = 'png';
        figCaptured.Caption = 'Оригинальное изображение для анализа';
        add(secClassification, figCaptured);
        add(rpt, secClassification);
        
        % Digital Twin Section
        secDigitalTwin = Section('Цифровой двойник и ИК-данные');
        
        imgTwinTitle = Paragraph('Визуализация цифрового двойника:');
        imgTwinTitle.FontSize = '12pt';
        imgTwinTitle.Bold = true;
        add(secDigitalTwin, imgTwinTitle);

        figTwin = Figure(Image(twin));
        figTwin.SnapshotFormat = 'png';
        figTwin.Caption = 'Цифровой двойник (комбинация видимого спектра и ИК-данных)';
        add(secDigitalTwin, figTwin);

        if isnumeric(irData) && ~isempty(irData)
            irPlotTitle = Paragraph('Данные ИК-сканирования:');
            irPlotTitle.FontSize = '12pt';
            irPlotTitle.Bold = true;
            add(secDigitalTwin, irPlotTitle);
            
            tempFig = figure('Visible', 'off', 'Units', 'pixels', 'Position', [0 0 600 400]);
            plot(irData);
            title('График ИК-сканирования');
            xlabel('Индекс данных');
            ylabel('Значение ИК-сигнала');
            grid on;
            
            imgIR = Image(getframe(tempFig).cdata);
            figIR = Figure(imgIR);
            figIR.SnapshotFormat = 'png';
            figIR.Caption = 'Графическое представление данных ИК-сканирования';
            add(secDigitalTwin, figIR);
            close(tempFig);
        end
        add(rpt, secDigitalTwin);
        
        close(rpt);
        rptview(rpt);
        msgbox('Отчет успешно создан и открыт.', 'Генерация отчета', 'help');

    catch ME_report
        errMsg = sprintf('Ошибка при генерации PDF отчета: %s', ME_report.message);
        if ~isempty(ME_report.stack)
            errMsg = sprintf('%s\nВ файле: %s (строка %d)', errMsg, ME_report.stack(1).name, ME_report.stack(1).line);
        end
        errordlg(errMsg, 'Ошибка генерации отчета');
    end
end

